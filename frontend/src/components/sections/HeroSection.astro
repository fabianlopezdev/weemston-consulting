---
import { urlForImage } from '@lib/sanity/image';
import { resolveLinkUrl } from '@lib/sanity/linkResolver';
import {
  resolveButtonColor,
  resolveButtonTextColor,
  resolveBackgroundStyle,
} from '@lib/sanity/colorResolver';
import { sanityClient as client } from 'sanity:client';
import { siteSettingsQuery } from '@lib/sanity/queries';
import { toPlainText } from '@portabletext/toolkit';
import type { PortableTextBlock } from '@portabletext/types';

interface LinkData {
  linkType: 'internal' | 'external';
  internalPageType?:
    | 'homepage'
    | 'servicesPage'
    | 'caseStudiesPage'
    | 'contactPage'
    | 'aboutPage'
    | 'service'
    | 'caseStudy'
    | 'legal';
  serviceReference?: { slug: { current: string } };
  caseStudyReference?: { slug: { current: string } };
  legalReference?: { slug: { current: string } };
  externalUrl?: string;
  text: string;
  openInNewTab?: boolean;
  buttonColor?: any;
}

// Flat structure for background settings (no nesting)
interface BackgroundSettings {
  backgroundType?: 'image' | 'color';
  image?: any;
  colorMode?: 'solid' | 'gradient';
  solidColor?: any;
  gradient?: any;
}

interface Props {
  tagline?: string;
  taglineColor?: 'base' | 'contrast';
  heading: PortableTextBlock[] | string;
  headingColor?: 'base' | 'contrast';
  subheading?: string;
  subheadingColor?: 'base' | 'contrast';
  ctaButton?: LinkData;
  backgroundSettings?: BackgroundSettings;
}

const {
  tagline,
  taglineColor,
  heading,
  headingColor,
  subheading,
  subheadingColor,
  ctaButton,
  backgroundSettings,
} = Astro.props;

// Fetch site settings for colors
const settings = await client.fetch(siteSettingsQuery);

// Resolve background style
const bgStyle = resolveBackgroundStyle(backgroundSettings, settings?.colors);

// For image backgrounds, generate the URL
let bgImageUrl: string | null = null;
if (bgStyle.type === 'image' && bgStyle.image) {
  bgImageUrl = urlForImage(bgStyle.image).width(1920).height(1080).url();
}

// Helper to resolve text color
const getTextColor = (color?: 'base' | 'contrast') =>
  color === 'base' ? '#1a1a1a' : undefined; // undefined = use default white from CSS

// Convert heading to HTML with line breaks
const getHeadingHtml = (
  content: PortableTextBlock[] | string | undefined
): string => {
  if (!content) return '';
  // Handle legacy string content
  if (typeof content === 'string') return content;
  // Extract text from each block and join with single <br>
  // toPlainText adds double newlines between blocks, so we extract manually
  const lines = content.map((block) => {
    if (block._type === 'block' && block.children) {
      return (block.children as Array<{ text?: string }>)
        .map((child) => child.text || '')
        .join('');
    }
    return '';
  });
  return lines.filter(Boolean).join('<br>');
};

const ctaHref = ctaButton ? resolveLinkUrl(ctaButton) : null;
const ctaOpenInNewTab =
  ctaButton?.openInNewTab || ctaButton?.linkType === 'external';

const ctaColor = ctaButton
  ? resolveButtonColor(ctaButton.buttonColor, settings?.colors)
  : null;
const ctaTextColor = ctaButton
  ? resolveButtonTextColor(ctaButton.buttonColor)
  : null;
---

<section class="hero" data-header-theme="dark">
  <div class="hero__background">
    {
      bgStyle.type === 'image' ? (
        bgImageUrl ? (
          <img
            src={bgImageUrl}
            alt={bgStyle.image?.alt || ''}
            class="hero__image"
          />
        ) : (
          <div class="hero__fallback" />
        )
      ) : (
        <div class="hero__color-bg" style={`background: ${bgStyle.css};`} />
      )
    }
  </div>
  <div class="hero__content container">
    <h1
      class="hero__heading"
      style={getTextColor(headingColor)
        ? `color: ${getTextColor(headingColor)}`
        : undefined}
      set:html={getHeadingHtml(heading)}
    />
    {
      subheading && (
        <p
          class="hero__intro"
          style={
            getTextColor(subheadingColor)
              ? `color: ${getTextColor(subheadingColor)}`
              : undefined
          }
        >
          {subheading}
        </p>
      )
    }
    {
      tagline && (
        <p
          class="hero__subheading"
          style={
            getTextColor(taglineColor)
              ? `color: ${getTextColor(taglineColor)}`
              : undefined
          }
        >
          {tagline}
        </p>
      )
    }
    {
      ctaButton && ctaHref && (
        <a
          href={ctaHref}
          class="hero__cta"
          style={
            ctaColor || ctaTextColor
              ? `${ctaColor ? `background: ${ctaColor};` : ''} ${ctaTextColor ? `color: ${ctaTextColor};` : ''}`.trim()
              : undefined
          }
          target={ctaOpenInNewTab ? '_blank' : undefined}
          rel={ctaOpenInNewTab ? 'noopener noreferrer' : undefined}
        >
          {ctaButton.text}
        </a>
      )
    }
  </div>
</section>

<style>
  .hero {
    /* Initial clip values (clipped state - expands on scroll) */
    --hero-clip: 2vw;
    --hero-radius: var(--border-radius-lg);

    /* Use clip-path for the expand/contract effect */
    /* Top is already expanded (0), only sides and bottom animate */
    clip-path: inset(
      0 var(--hero-clip) var(--hero-clip) var(--hero-clip) round
        var(--hero-radius)
    );

    height: calc(100dvh - var(--header-height) - var(--space-lg));
    display: flex;
    align-items: center;
    overflow: visible;
    background-color: var(--color-primary);
    position: relative; /* Ensure positioning context */
    will-change: clip-path; /* Optimize for animation */
  }

  .hero__background {
    position: absolute;
    inset: 0;
    z-index: 0;
    transform: scale(var(--hero-scale, 1));
    will-change: transform;
    transform-origin: center center;
  }

  /* Gradient Overlay */
  .hero__background::after {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(
      to bottom,
      rgba(0, 0, 0, 0.1),
      rgba(0, 0, 0, 0.5)
    );
    z-index: 1;
    pointer-events: none;
  }

  .hero__fallback {
    width: 100%;
    height: 100%;
    background: linear-gradient(
      135deg,
      var(--color-primary) 30%,
      var(--color-accent) 120%
    );
  }

  .hero__color-bg {
    width: 100%;
    height: 100%;
  }

  .hero__image {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  .hero__content {
    position: relative;
    z-index: 2; /* Ensure content is above overlay */
    text-align: center;
    color: white; /* Ensure text is white on dark overlay/gradient */
    /* No max-width - title can span full width, user controls breaks in Sanity */
    /* Horizontal padding provided by .container class */

    /* Entry Animation */
    animation: slideUpFade 0.8s ease-out forwards;
    opacity: 0;
    transform: translateY(20px);
  }

  @keyframes slideUpFade {
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .hero__heading {
    font-family: var(--font-heading); /* Lora */
    font-size: var(--font-size-4xl);
    margin-block-end: var(--space-md);
    line-height: 1.1;
    font-weight: 400;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    /* Break out of container constraint to span full hero width */
    width: 100vw;
    margin-inline: calc(50% - 50vw);
    padding-inline: var(--space-lg);
    box-sizing: border-box;
  }

  .hero__subheading {
    font-size: var(--font-size-lg);
    margin-block-end: var(--space-md);
    opacity: 0.9;
    margin-inline: auto;
  }

  .hero__intro {
    font-size: var(--font-size-lg);
    margin-block-end: var(--space-lg);
    opacity: 0.9;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    max-width: 60ch;
    margin-inline: auto;
  }

  .hero__cta {
    display: inline-block;
    padding: var(--button-padding-vertical, var(--space-md))
      var(--button-padding-horizontal, var(--space-lg));
    background: var(--color-primary, #0066cc);
    color: white; /* Default, overridden by inline style when buttonColor is set */
    text-decoration: none;
    border-radius: var(--button-border-radius, 4px);
    font-weight: 600;
    transition:
      transform 0.2s,
      background 0.2s,
      color 0.2s;
  }

  .hero__cta:hover {
    transform: translateY(-2px);
    background: var(--color-primary-dark, #0052a3);
  }

  @media (max-width: 768px) {
    .hero {
      height: auto;
      min-height: 50vh;
    }

    .hero__heading {
      font-size: var(--font-size-2xl);
    }

    .hero__subheading {
      font-size: var(--font-size-base);
    }

    .hero__intro {
      font-size: var(--font-size-sm);
    }
  }
</style>

<script>
  import { setupAnimationLifecycle, createHeroReveal } from '@lib/animation';

  setupAnimationLifecycle(() => {
    createHeroReveal('.hero', '.hero__background', {
      finalScale: 1.15,
    });
  });
</script>
