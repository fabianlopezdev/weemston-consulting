---
import { urlForImageWithSeoFilename } from '@lib/sanity/image';
import { resolveColorSelection } from '@lib/sanity/colorResolver';
import { sanityClient as client } from 'sanity:client';
import { siteSettingsQuery } from '@lib/sanity/queries';
import SectionTitle from '@components/ui/SectionTitle.astro';
import PortableText from '@components/sanity/PortableText.astro';
import PortraitImage from '@components/ui/PortraitImage.astro';
import type { PortableTextBlock } from '@portabletext/types';

interface ImageAsset {
  _id: string;
  url: string;
  metadata?: {
    lqip?: string;
    dimensions?: {
      width: number;
      height: number;
      aspectRatio: number;
    };
  };
}

interface SanityImage {
  asset?: ImageAsset;
  alt?: string;
  seoFilename?: string;
  hotspot?: { x: number; y: number };
  crop?: { top: number; bottom: number; left: number; right: number };
}

interface ColorData {
  label?: string;
  value: string;
}

interface GradientColorData {
  colorType?: 'primary' | 'secondary' | 'accent' | 'custom';
  shade?: number;
  customColor?: ColorData;
}

interface GradientData {
  direction?: string;
  startColor?: GradientColorData;
  endColor?: GradientColorData;
}

interface Props {
  tagline?: string;
  taglineColorType?: 'primary' | 'secondary' | 'accent' | 'custom';
  taglineColorShade?: number;
  taglineCustomColor?: ColorData;
  title: string;
  titleColorType?: 'primary' | 'secondary' | 'accent' | 'custom';
  titleColorShade?: number;
  titleCustomColor?: ColorData;
  content?: PortableTextBlock[];
  textColor?: 'base' | 'muted' | 'contrast';
  quote?: string; // Kept for legacy quote color styling
  quoteColorType?: 'primary' | 'secondary' | 'accent' | 'custom';
  quoteColorShade?: number;
  quoteCustomColor?: ColorData;
  image?: SanityImage;
  backgroundColorType?:
    | 'default'
    | 'primary'
    | 'secondary'
    | 'accent'
    | 'custom';
  backgroundColorMode?: 'solid' | 'gradient';
  backgroundColorShade?: number;
  backgroundCustomColor?: ColorData;
  backgroundGradient?: GradientData;
}

const {
  tagline,
  taglineColorType = 'accent',
  taglineColorShade = 0,
  taglineCustomColor,
  title,
  titleColorType = 'accent',
  titleColorShade = 0,
  titleCustomColor,
  content,
  textColor = 'muted',
  quote,
  quoteColorType = 'accent',
  quoteColorShade = 0,
  quoteCustomColor,
  image,
  backgroundColorType = 'default',
  backgroundColorMode = 'solid',
  backgroundColorShade = 90,
  backgroundCustomColor,
  backgroundGradient,
} = Astro.props;

// Fetch site settings for colors
const settings = await client.fetch(siteSettingsQuery);
const siteColors = settings?.colors;

// Resolve background color (check gradient mode first, since colorType stays 'default' when hidden)
const backgroundColor =
  backgroundColorMode === 'gradient' && backgroundGradient
    ? `linear-gradient(${backgroundGradient.direction || '135deg'}, ${resolveColorSelection(backgroundGradient.startColor, siteColors)}, ${resolveColorSelection(backgroundGradient.endColor, siteColors)})`
    : backgroundColorType === 'default'
      ? null
      : resolveColorSelection(
          {
            colorType: backgroundColorType,
            shade: backgroundColorShade,
            customColor: backgroundCustomColor,
          },
          siteColors
        );

// Resolve tagline color
const taglineColor = resolveColorSelection(
  {
    colorType: taglineColorType,
    shade: taglineColorShade,
    customColor: taglineCustomColor,
  },
  siteColors
);

// Resolve title color
const titleColor = resolveColorSelection(
  {
    colorType: titleColorType,
    shade: titleColorShade,
    customColor: titleCustomColor,
  },
  siteColors
);

// Resolve quote color
const quoteColor = resolveColorSelection(
  {
    colorType: quoteColorType,
    shade: quoteColorShade,
    customColor: quoteCustomColor,
  },
  siteColors
);

// Text color mapping (for content)
const textColorMap = {
  base: 'var(--color-text)',
  muted: 'var(--color-text-muted)',
  contrast: 'rgba(255, 255, 255, 0.9)',
};

const cssVars = [
  backgroundColor ? `--founder-bg: ${backgroundColor}` : null,
  `--founder-tagline-color: ${taglineColor}`,
  `--founder-title-color: ${titleColor}`,
  `--founder-text-color: ${textColorMap[textColor]}`,
  `--founder-quote-color: ${quoteColor}`,
]
  .filter(Boolean)
  .join('; ');

// Generate image URL
const imageUrl = image?.asset
  ? urlForImageWithSeoFilename(
      image as {
        asset?: { _ref?: string };
        alt?: string;
        seoFilename?: string;
      },
      { width: 800, quality: 85 }
    )
  : null;

const imageLqip = image?.asset?.metadata?.lqip;

// Normalize text for comparison (trim, collapse spaces/tabs but preserve newlines)
function normalizeText(text: string): string {
  return text.trim().replace(/[^\S\n]+/g, ' ');
}

// Span type for Portable Text children
interface PTSpan {
  _type: string;
  _key?: string;
  text?: string;
  marks?: string[];
}

// Extract plain text from a block
function extractTextFromBlock(block: PortableTextBlock): string {
  if (block._type !== 'block' || !block.children) return '';
  return (block.children as PTSpan[])
    .filter((child) => child._type === 'span')
    .map((span) => span.text || '')
    .join('');
}

// Content part types for rendering
type ContentPart =
  | { type: 'paragraph'; block: PortableTextBlock }
  | { type: 'quote'; text: string }
  | { type: 'before'; block: PortableTextBlock }
  | { type: 'after'; block: PortableTextBlock };

// Split a block's spans around a quote, preserving formatting
function splitBlockAroundQuote(
  block: PortableTextBlock,
  quoteText: string
): {
  before: PortableTextBlock | null;
  quote: string;
  after: PortableTextBlock | null;
} | null {
  if (block._type !== 'block' || !block.children) return null;

  const spans = (block.children as PTSpan[]).filter((c) => c._type === 'span');
  const fullText = spans.map((s) => s.text || '').join('');
  const normalizedFull = normalizeText(fullText);
  const normalizedQuote = normalizeText(quoteText);

  const quoteStartNorm = normalizedFull.indexOf(normalizedQuote);
  if (quoteStartNorm === -1) return null;

  // Map normalized position back to original text position
  // Build a mapping: for each char in normalized, track original position
  let normIndex = 0;
  let origIndex = 0;
  const normToOrig: number[] = [];
  const trimmedFull = fullText.trim();
  const leadingSpaces = fullText.length - fullText.trimStart().length;

  // Account for leading trim
  origIndex = leadingSpaces;
  for (let i = 0; i < trimmedFull.length; i++) {
    const char = trimmedFull.charAt(i);
    if (/[^\S\n]/.test(char)) {
      // Skip consecutive non-newline whitespace after first
      if (i === 0 || !/[^\S\n]/.test(trimmedFull.charAt(i - 1))) {
        normToOrig.push(origIndex);
        normIndex++;
      }
    } else {
      // Regular char or newline - always include
      normToOrig.push(origIndex);
      normIndex++;
    }
    origIndex++;
  }
  normToOrig.push(origIndex); // End position

  const quoteStartOrig = normToOrig[quoteStartNorm] ?? 0;
  const quoteEndOrig =
    normToOrig[quoteStartNorm + normalizedQuote.length] ?? fullText.length;

  // Now split spans at quoteStartOrig and quoteEndOrig
  const beforeSpans: PTSpan[] = [];
  const afterSpans: PTSpan[] = [];
  let currentPos = 0;

  for (const span of spans) {
    const spanText = span.text || '';
    const spanStart = currentPos;
    const spanEnd = currentPos + spanText.length;

    if (spanEnd <= quoteStartOrig) {
      // Entirely before quote
      beforeSpans.push({ ...span });
    } else if (spanStart >= quoteEndOrig) {
      // Entirely after quote
      afterSpans.push({ ...span });
    } else {
      // Span overlaps with quote - need to split
      if (spanStart < quoteStartOrig) {
        // Part before quote
        const beforeText = spanText.slice(0, quoteStartOrig - spanStart);
        if (beforeText) {
          beforeSpans.push({
            ...span,
            _key: `${span._key || 'span'}-before`,
            text: beforeText,
          });
        }
      }
      if (spanEnd > quoteEndOrig) {
        // Part after quote
        const afterText = spanText.slice(quoteEndOrig - spanStart);
        if (afterText) {
          afterSpans.push({
            ...span,
            _key: `${span._key || 'span'}-after`,
            text: afterText,
          });
        }
      }
    }
    currentPos = spanEnd;
  }

  // Create before block if there's content
  const beforeBlock: PortableTextBlock | null =
    beforeSpans.length > 0
      ? ({
          ...block,
          _key: `${block._key || 'block'}-before`,
          children: beforeSpans,
        } as PortableTextBlock)
      : null;

  // Create after block if there's content
  const afterBlock: PortableTextBlock | null =
    afterSpans.length > 0
      ? ({
          ...block,
          _key: `${block._key || 'block'}-after`,
          children: afterSpans,
        } as PortableTextBlock)
      : null;

  // Extract the actual quote text from original
  const extractedQuote = fullText.slice(quoteStartOrig, quoteEndOrig).trim();

  return { before: beforeBlock, quote: extractedQuote, after: afterBlock };
}

// Parse all content blocks, splitting the one containing the quote
function parsePortableTextContent(
  blocks: PortableTextBlock[],
  quoteText?: string
): ContentPart[] {
  if (!blocks?.length) return [];
  if (!quoteText) {
    return blocks.map((block) => ({ type: 'paragraph' as const, block }));
  }

  const normalizedQuote = normalizeText(quoteText);
  const parts: ContentPart[] = [];
  let quoteFound = false;

  for (const block of blocks) {
    if (!quoteFound && block._type === 'block') {
      const blockText = extractTextFromBlock(block);
      const normalizedBlock = normalizeText(blockText);

      if (normalizedBlock.includes(normalizedQuote)) {
        // This block contains the quote - split it
        const split = splitBlockAroundQuote(block, quoteText);
        if (split) {
          if (split.before) {
            parts.push({ type: 'before', block: split.before });
          }
          parts.push({ type: 'quote', text: split.quote });
          if (split.after) {
            parts.push({ type: 'after', block: split.after });
          }
          quoteFound = true;
          continue;
        }
      }
    }
    parts.push({ type: 'paragraph', block });
  }

  return parts;
}

const contentParts = parsePortableTextContent(content || [], quote);
---

<section
  class:list={['founder-section', { 'founder-section--no-image': !imageUrl }]}
  style={cssVars}
>
  <div class="container">
    <div
      class:list={[
        'founder-section__grid',
        { 'founder-section__grid--no-image': !imageUrl },
      ]}
    >
      {
        imageUrl && (
          <PortraitImage
            src={imageUrl}
            alt={image?.alt || ''}
            lqip={imageLqip}
          />
        )
      }
      <div class="founder-section__content">
        {tagline && <span class="founder-section__tagline">{tagline}</span>}
        <SectionTitle
          title={title}
          color={titleColor}
          align={imageUrl ? 'left' : 'center'}
          class="founder-section__title"
        />
        {
          contentParts.length > 0 && (
            <div class="founder-section__text">
              {contentParts.map((part) =>
                part.type === 'quote' ? (
                  <blockquote class="founder-section__quote">
                    "{part.text}"
                  </blockquote>
                ) : (
                  <PortableText content={[part.block]} />
                )
              )}
            </div>
          )
        }
      </div>
    </div>
  </div>
</section>

<style>
  .founder-section {
    padding-bottom: var(--space-2xl);
    background: var(--founder-bg, transparent);
  }

  .founder-section--no-image {
    padding-top: var(--space-2xl);
  }

  .founder-section__grid {
    display: grid;
    grid-template-columns: 1fr;
    gap: var(--space-xl);
    align-items: center;
  }

  @media (min-width: 768px) {
    .founder-section__grid {
      grid-template-columns: 1fr 1fr;
      gap: var(--space-2xl);
    }

    .founder-section__grid--no-image {
      grid-template-columns: 1fr;
      max-width: 48rem;
      margin: 0 auto;
      text-align: center;
    }
  }

  .founder-section__content {
    padding: var(--space-md) 0;
  }

  .founder-section__tagline {
    display: block;
    font-size: 0.875rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--founder-tagline-color, var(--color-accent));
    margin-bottom: var(--space-sm);
  }

  .founder-section__text {
    color: var(--founder-text-color, var(--color-text-muted));
  }

  .founder-section__text :global(p) {
    margin: 0 0 var(--space-md);
    line-height: 1.7;
    white-space: pre-line;
  }

  .founder-section__text :global(p:last-child) {
    margin-bottom: 0;
  }

  .founder-section__text :global(p:empty) {
    min-height: 1em;
  }

  .founder-section__quote {
    border-left: 3px solid var(--founder-quote-color, var(--color-accent));
    padding-left: var(--space-md);
    margin: var(--space-lg) 0;
    font-family: var(--font-heading);
    font-size: clamp(1.125rem, 2.5vw, 1.35rem);
    font-style: italic;
    color: var(--founder-quote-color, var(--color-accent));
    line-height: 1.5;
  }

  .founder-section__quote:last-child {
    margin-bottom: 0;
  }

  .founder-section__grid--no-image .founder-section__quote {
    border-left: none;
    padding-left: 0;
  }

  .founder-section__text .founder-section__quote + :global(p) {
    margin-top: var(--space-lg);
  }
</style>

<script>
  import { setupAnimationLifecycle, gsap } from '@lib/animation/utils';
  import { ANIMATION_CONFIG } from '@lib/animation/config';

  setupAnimationLifecycle(() => {
    const section = document.querySelector('.founder-section');
    const tagline = document.querySelector('.founder-section__tagline');
    const title = document.querySelector('.founder-section__title');
    const paragraphs = document.querySelectorAll('.founder-section__text p');
    const quote = document.querySelector('.founder-section__quote');

    if (!section) return;

    // Initial states for content elements
    if (tagline) gsap.set(tagline, { opacity: 0, y: 20 });
    if (title) gsap.set(title, { opacity: 0, y: 30 });
    paragraphs.forEach((p) => gsap.set(p, { opacity: 0, y: 25 }));
    if (quote) gsap.set(quote, { opacity: 0, x: -30 });

    // Create content timeline
    const contentTl = gsap.timeline({
      scrollTrigger: {
        trigger: '.founder-section__content',
        start: 'top 80%',
        once: true,
        markers: ANIMATION_CONFIG.scrollTrigger.markers,
      },
    });

    // Tagline fades in first
    if (tagline) {
      contentTl.to(tagline, {
        opacity: 1,
        y: 0,
        duration: 0.5,
        ease: 'power2.out',
      });
    }

    // Title follows
    if (title) {
      contentTl.to(
        title,
        {
          opacity: 1,
          y: 0,
          duration: 0.6,
          ease: 'power3.out',
        },
        '-=0.2'
      );
    }

    // Paragraphs stagger in
    if (paragraphs.length > 0) {
      contentTl.to(
        paragraphs,
        {
          opacity: 1,
          y: 0,
          duration: 0.5,
          ease: 'power2.out',
          stagger: 0.15,
        },
        '-=0.3'
      );
    }

    // Quote slides in from left
    if (quote) {
      contentTl.to(
        quote,
        {
          opacity: 1,
          x: 0,
          duration: 0.6,
          ease: 'power3.out',
        },
        '-=0.4'
      );
    }
  });
</script>
