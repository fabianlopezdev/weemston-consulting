---
import SectionTitle from '@components/ui/SectionTitle.astro';
import { resolveColorSelection } from '@lib/sanity/colorResolver';
import { sanityClient as client } from 'sanity:client';
import { siteSettingsQuery } from '@lib/sanity/queries';

interface ColorData {
  label?: string;
  value: string;
}

interface HowWeWorkCard {
  _key: string;
  title: string;
  description: string;
}

interface Props {
  title: string;
  description?: string;
  cards: HowWeWorkCard[];
  // Color settings
  backgroundColorType?:
    | 'default'
    | 'primary'
    | 'secondary'
    | 'accent'
    | 'custom';
  backgroundColorShade?: number;
  backgroundCustomColor?: ColorData;
  accentColorType?: 'primary' | 'secondary' | 'accent' | 'custom';
  accentCustomColor?: ColorData;
  textColor?: 'base' | 'contrast';
}

const {
  title,
  description,
  cards,
  backgroundColorType = 'default',
  backgroundColorShade = 0,
  backgroundCustomColor,
  accentColorType = 'secondary',
  accentCustomColor,
  textColor = 'base',
} = Astro.props;

// Fetch site settings for colors
const settings = await client.fetch(siteSettingsQuery);
const siteColors = settings?.colors;

// Resolve background color (null if default)
const backgroundColor =
  backgroundColorType === 'default' || !backgroundColorType
    ? null
    : resolveColorSelection(
        {
          colorType: backgroundColorType,
          shade: backgroundColorShade,
          customColor: backgroundCustomColor,
        },
        siteColors
      );

// Resolve accent color (no shade)
const accentColor = resolveColorSelection(
  {
    colorType: accentColorType,
    customColor: accentCustomColor,
  },
  siteColors
);

// Define CSS variables for dynamic colors
const cssVars: Record<string, string> = {
  '--hww-accent': accentColor,
  '--hww-text':
    textColor === 'contrast'
      ? 'var(--color-text-contrast)'
      : 'var(--color-text)',
  '--hww-text-muted':
    textColor === 'contrast'
      ? 'var(--color-text-contrast)'
      : 'var(--color-text-muted)',
};

// Only set background if not default
if (backgroundColor) {
  cssVars['--hww-bg'] = backgroundColor;
}

const cssVarsString = Object.entries(cssVars)
  .map(([key, value]) => `${key}: ${value}`)
  .join('; ');
---

<section class="how-we-work-section" style={cssVarsString}>
  <div class="container">
    <div class="how-we-work-section__header">
      <SectionTitle>{title}</SectionTitle>
      {
        description && (
          <p class="how-we-work-section__description">{description}</p>
        )
      }
    </div>

    <div class="timeline">
      {/* SVG will be generated by JavaScript at runtime */}
      <svg class="timeline__svg" aria-hidden="true">
        <path
          class="timeline__path"
          fill="none"
          stroke-width="3"
          stroke-linecap="round"
          stroke-linejoin="round"></path>
      </svg>
      {
        cards.map((card, index) => (
          <div class="timeline__item" style={`--item-index: ${index}`}>
            <div class="timeline__marker">
              <span class="timeline__number">
                {(index + 1).toString().padStart(2, '0')}
              </span>
            </div>
            <div class="timeline__content">
              <h3 class="timeline__title">{card.title}</h3>
              <p class="timeline__description">{card.description}</p>
            </div>
          </div>
        ))
      }
    </div>
  </div>
</section>

<style>
  .how-we-work-section {
    --hww-marker-size: 80px;
    --hww-number-size: clamp(1.75rem, 4vw, 2.5rem);
    --hww-item-gap: clamp(3rem, 6vw, 5rem);
    --hww-base-indent: 2rem;

    position: relative;
    padding: var(--space-3xl) 0;
    background: var(--hww-bg, var(--color-background));
    overflow: hidden;
  }

  /* Subtle paper texture overlay */
  .how-we-work-section::before {
    content: '';
    position: absolute;
    inset: 0;
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
    opacity: 0.08;
    pointer-events: none;
    z-index: 0;
  }

  /* Soft vertical gradient */
  .how-we-work-section::after {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(
      to bottom,
      transparent 0%,
      rgba(0, 0, 0, 0.05) 50%,
      transparent 100%
    );
    pointer-events: none;
    z-index: 0;
  }

  .how-we-work-section > .container {
    position: relative;
    z-index: 1;
  }

  .how-we-work-section__header {
    text-align: center;
    margin-block-end: var(--space-2xl);
  }

  .how-we-work-section__description {
    font-size: var(--font-size-lg);
    max-width: 600px;
    margin-inline: auto;
    color: var(--hww-text-muted, var(--color-text-muted));
  }

  .timeline {
    position: relative;
    max-width: 650px;
    margin-inline: auto;
    padding-inline-start: 1rem;
  }

  .timeline__svg {
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    z-index: 0;
    overflow: visible;
  }

  .timeline__path {
    stroke: var(--hww-accent, var(--color-secondary));
    stroke-width: 2px;
    opacity: 0.6;
  }

  .timeline__item {
    display: flex;
    flex-direction: row;
    align-items: flex-start;
    gap: var(--hww-base-indent, 2rem);
    position: relative;
    padding-bottom: var(--hww-item-gap);
    max-width: 85%;
  }

  /* Staggered Layout for Desktop */
  @media (min-width: 768px) {
    /* Use nth-of-type to ignore the SVG element which is the first child */
    .timeline__item:nth-of-type(even) {
      margin-left: auto;
      flex-direction: row;
    }

    .timeline__item:nth-of-type(odd) {
      margin-right: auto;
    }
  }

  .timeline__item:last-child {
    padding-bottom: 0;
  }

  .timeline__marker {
    position: relative;
    z-index: 2;
    display: flex;
    align-items: center;
    justify-content: center;
    width: var(--hww-marker-size);
    height: var(--hww-marker-size);
    min-width: var(--hww-marker-size);
    border-radius: 50%;
    background-color: var(--hww-bg, var(--color-background));
    border: 1.5px solid var(--hww-accent, var(--color-secondary));
    box-shadow:
      inset 0 0 0 3px var(--hww-bg, var(--color-background)),
      inset 0 0 0 4.5px
        color-mix(
          in srgb,
          var(--hww-accent, var(--color-secondary)) 30%,
          transparent
        );
    transform-origin: center;
  }

  .timeline__number {
    font-family: var(--font-heading);
    font-size: var(--hww-number-size);
    font-weight: 400;
    font-style: italic;
    letter-spacing: -0.02em;
    color: var(--hww-text, var(--color-text));
    /* Compensate for italic slant pushing text right */
    margin-left: -0.1em;
  }

  .timeline__content {
    padding-top: 1rem;
    flex: 1;
  }

  .timeline__title {
    font-size: var(--font-size-2xl);
    font-weight: var(--font-weight-semibold);
    margin: 0 0 0.75rem;
    font-family: var(--font-heading);
    font-style: italic;
    color: var(--hww-text, var(--color-text));
  }

  .timeline__description {
    font-size: var(--font-size-sm);
    color: var(--hww-text-muted, var(--color-text-muted));
    line-height: 1.7;
    margin: 0;
    opacity: 0.85;
  }

  @media (max-width: 480px) {
    .how-we-work-section {
      --hww-marker-size: 65px;
      --hww-item-gap: clamp(2.5rem, 5vw, 3.5rem);
    }

    .timeline {
      padding-inline-start: 0;
    }

    .timeline__svg {
      /* Reset to default full coverage if overridden */
      left: 0;
      width: 100%;
    }

    .timeline__item {
      /* Simpler gap for mobile */
      gap: 1.5rem;
      max-width: 100%; /* Use full width on mobile */
    }
  }
</style>

<script>
  import { setupAnimationLifecycle, gsap } from '@lib/animation';

  function generateWavyPath(markers: { x: number; y: number }[]): string {
    if (markers.length < 2) return '';

    const firstMarker = markers[0];
    if (!firstMarker) return '';
    let path = `M ${firstMarker.x} ${firstMarker.y}`;

    // Define curve intensity
    // A fixed horizontal offset ensures the line is always "wavy" even if vertical
    const amplitude = 40;

    for (let i = 0; i < markers.length - 1; i++) {
      const start = markers[i];
      const end = markers[i + 1];
      if (!start || !end) continue;

      const distY = end.y - start.y;

      // Alternate direction for each segment to create a serpentine flow
      // If we simply used the same direction, it might look like a displaced C-curve.
      // Alternating creates an S-wave or continuous ripple.
      // We rely on the natural zigzag of the layout, but adding this ensures curl.
      // Note: The layout is Left -> Right -> Left.
      // Segment 0 (Left->Right): Bulging "up/left" or "down/right"?
      // Let's force some perpendicular-ish curvature.

      // Direction: 1 for even segments (Left->Right), -1 for odd (Right->Left).
      // We want to exaggerate the curve by pushing control points OUTWARD relative to the flow.
      // If moving Left->Right (dir=1), we want cp1 to bulge Left (-x) and cp2 to bulge Right (+x).
      const dir = i % 2 === 0 ? 1 : -1;

      // Control points
      // We push the control points AWAY from the center of the span to create the 'Overshoot' look
      // Previous logic pushed them INWARD which straightened the line.
      const cp1 = {
        x: start.x - amplitude * dir,
        y: start.y + distY * 0.5,
      };

      const cp2 = {
        x: end.x + amplitude * dir,
        y: end.y - distY * 0.5,
      };

      path += ` C ${cp1.x} ${cp1.y}, ${cp2.x} ${cp2.y}, ${end.x} ${end.y}`;
    }

    return path;
  }

  function initTimelinePath() {
    const timeline = document.querySelector('.timeline') as HTMLElement;
    const svg = document.querySelector('.timeline__svg') as SVGSVGElement;
    const path = document.querySelector('.timeline__path') as SVGPathElement;
    const markers = document.querySelectorAll('.timeline__marker');

    if (!timeline || !svg || !path || markers.length < 2) return;

    // Get the timeline's position for relative calculations
    const timelineRect = timeline.getBoundingClientRect();

    // Set SVG dimensions to match timeline exactly
    const svgWidth = timelineRect.width;
    const svgHeight = timelineRect.height;

    svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);

    // Get center positions of each marker relative to the timeline
    const markerPositions: { x: number; y: number }[] = [];
    markers.forEach((marker) => {
      const rect = marker.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2 - timelineRect.left;
      const centerY = rect.top + rect.height / 2 - timelineRect.top;
      markerPositions.push({ x: centerX, y: centerY });
    });

    // Generate and set the path
    const pathD = generateWavyPath(markerPositions);
    path.setAttribute('d', pathD);

    return path;
  }

  setupAnimationLifecycle(() => {
    const timeline = document.querySelector('.timeline') as HTMLElement;
    if (!timeline) return;

    // Mobile check - disable draggable on small screens
    const isMobile = window.matchMedia('(max-width: 768px)').matches;

    // Function to run path calculation
    const updatePath = () => {
      // Small safety check to ensure element is still in DOM
      if (!timeline.isConnected) return;
      const path = initTimelinePath();

      // Update stroke-dasharray to accommodate new length
      // This prevents the line from "breaking" or showing gaps if stretched beyond original length
      if (path) {
        const len = path.getTotalLength();
        path.style.strokeDasharray = `${len}`;
        // Preserve hidden state - only set if not already animated
        // Check if strokeDashoffset is unset or needs initialization
        if (
          !path.style.strokeDashoffset ||
          path.style.strokeDashoffset === '0'
        ) {
          path.style.strokeDashoffset = `${len}`;
        }
      }
    };

    // Initial calculation (Synchronous) to ensure GSAP gets correct length
    // We still keep the ResizeObserver/Timeout for layout shifts
    if (timeline.isConnected) {
      const path = initTimelinePath();
      // Hide path immediately after initialization to prevent flash
      if (path) {
        const len = path.getTotalLength();
        path.style.strokeDasharray = `${len}`;
        path.style.strokeDashoffset = `${len}`;
      }
    }

    // Initial calculation with a small delay to ensure layout is settled
    // (Resolves potential race conditions with fonts/styles)
    setTimeout(updatePath, 100);

    // Use ResizeObserver for robust layout tracking
    const observer = new ResizeObserver(() => {
      // Debounce slightly to avoid thrashing
      requestAnimationFrame(() => updatePath());
    });
    observer.observe(timeline);

    // Initial Animation Setup
    const section = document.querySelector(
      '.how-we-work-section'
    ) as HTMLElement;
    const path = timeline.querySelector(
      '.timeline__svg path'
    ) as SVGPathElement;

    if (path && section) {
      // Get the total length of the SVG path
      const pathLength = path.getTotalLength();

      // Set up stroke-dasharray and initial dashoffset
      path.style.strokeDasharray = `${pathLength}`;
      path.style.strokeDashoffset = `${pathLength}`;

      const markers = document.querySelectorAll('.timeline__marker');
      const contents = document.querySelectorAll('.timeline__content');
      const numMarkers = markers.length;

      if (numMarkers < 2) return;

      // ===== MOBILE: Use viewport-based triggers (no pinning) =====
      if (isMobile) {
        markers.forEach((marker, index) => {
          gsap.fromTo(
            marker,
            { scale: 0 },
            {
              scale: 1,
              ease: 'back.out(1.5)',
              scrollTrigger: {
                trigger: marker,
                start: 'top 75%',
                end: 'top 55%',
                scrub: 0.5,
              },
            }
          );

          const content = contents[index];
          if (content) {
            gsap.fromTo(
              content,
              { opacity: 0, x: -15 },
              {
                opacity: 1,
                x: 0,
                ease: 'power2.out',
                scrollTrigger: {
                  trigger: marker,
                  start: 'top 70%',
                  end: 'top 50%',
                  scrub: 0.5,
                },
              }
            );
          }

          if (index < numMarkers - 1) {
            const nextMarker = markers[index + 1] as HTMLElement;
            if (!nextMarker) return;

            const segmentStart = pathLength * (1 - index / (numMarkers - 1));
            const segmentEnd =
              pathLength * (1 - (index + 1) / (numMarkers - 1));

            gsap.fromTo(
              path,
              { strokeDashoffset: segmentStart },
              {
                strokeDashoffset: segmentEnd,
                ease: 'none',
                immediateRender: false,
                scrollTrigger: {
                  trigger: marker,
                  start: 'top 55%',
                  end: () => {
                    const nextRect = nextMarker.getBoundingClientRect();
                    const currentRect = marker.getBoundingClientRect();
                    return `+=${Math.abs(nextRect.top - currentRect.top) - 50}`;
                  },
                  scrub: 1,
                },
              }
            );
          }
        });
      } else {
        // ===== DESKTOP: Two-phase approach with pinning =====

        const firstMarker = markers[0] as HTMLElement;
        const firstContent = contents[0];
        const remainingMarkers = Array.from(markers).slice(1) as HTMLElement[];
        const remainingContents = Array.from(contents).slice(1);

        // PHASE 1: First card uses viewport-based triggers (pre-pin)
        gsap.fromTo(
          firstMarker,
          { scale: 0 },
          {
            scale: 1,
            ease: 'back.out(1.5)',
            scrollTrigger: {
              trigger: firstMarker,
              start: 'top 75%',
              end: 'top 55%',
              scrub: 0.5,
            },
          }
        );

        if (firstContent) {
          gsap.fromTo(
            firstContent,
            { opacity: 0, x: -15 },
            {
              opacity: 1,
              x: 0,
              ease: 'power2.out',
              scrollTrigger: {
                trigger: firstMarker,
                start: 'top 70%',
                end: 'top 50%',
                scrub: 0.5,
              },
            }
          );
        }

        // First path segment (from first to second marker) - also pre-pin
        if (numMarkers > 1) {
          const secondMarker = markers[1] as HTMLElement;
          const segmentStart = pathLength * (1 - 0 / (numMarkers - 1));
          const segmentEnd = pathLength * (1 - 1 / (numMarkers - 1));

          gsap.fromTo(
            path,
            { strokeDashoffset: segmentStart },
            {
              strokeDashoffset: segmentEnd,
              ease: 'none',
              immediateRender: false,
              scrollTrigger: {
                trigger: firstMarker,
                start: 'top 55%',
                end: () => {
                  const nextRect = secondMarker.getBoundingClientRect();
                  const currentRect = firstMarker.getBoundingClientRect();
                  return `+=${Math.abs(nextRect.top - currentRect.top) - 50}`;
                },
                scrub: 1,
              },
            }
          );
        }

        // PHASE 2: Remaining cards reveal during pinned state
        if (remainingMarkers.length > 0) {
          const scrollPerCard = 300; // Scroll distance per card reveal
          const pinDuration = remainingMarkers.length * scrollPerCard;
          const timePerCard = 1 / remainingMarkers.length;

          // Create pinned timeline
          const pinnedTimeline = gsap.timeline({
            scrollTrigger: {
              trigger: section,
              start: 'top top',
              end: `+=${pinDuration}`,
              pin: true,
              pinSpacing: true,
              scrub: 1,
              anticipatePin: 1,
            },
          });

          // Add remaining cards to pinned timeline
          remainingMarkers.forEach((marker, relativeIndex) => {
            const absoluteIndex = relativeIndex + 1;
            const content = remainingContents[relativeIndex];
            const startTime = relativeIndex * timePerCard;

            // Marker scale animation
            pinnedTimeline.fromTo(
              marker,
              { scale: 0 },
              {
                scale: 1,
                ease: 'back.out(1.5)',
                duration: timePerCard * 0.5,
              },
              startTime
            );

            // Content fade animation
            if (content) {
              pinnedTimeline.fromTo(
                content,
                { opacity: 0, x: -15 },
                {
                  opacity: 1,
                  x: 0,
                  ease: 'power2.out',
                  duration: timePerCard * 0.6,
                },
                startTime + timePerCard * 0.15
              );
            }

            // SVG path segment (if not last marker)
            if (absoluteIndex < numMarkers - 1) {
              const segmentStart =
                pathLength * (1 - absoluteIndex / (numMarkers - 1));
              const segmentEnd =
                pathLength * (1 - (absoluteIndex + 1) / (numMarkers - 1));

              pinnedTimeline.fromTo(
                path,
                { strokeDashoffset: segmentStart },
                {
                  strokeDashoffset: segmentEnd,
                  ease: 'none',
                  duration: timePerCard * 0.8,
                  immediateRender: false,
                },
                startTime + timePerCard * 0.2
              );
            }
          });
        }
      }
    }
  });
</script>
