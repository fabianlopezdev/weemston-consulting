---
import SectionTitle from '@components/ui/SectionTitle.astro';
import { resolveColorSelection } from '@lib/sanity/colorResolver';
import { sanityClient as client } from 'sanity:client';
import { siteSettingsQuery } from '@lib/sanity/queries';

interface ColorData {
  label?: string;
  value: string;
}

interface HowWeWorkCard {
  _key: string;
  title: string;
  description: string;
}

interface Props {
  title: string;
  description?: string;
  cards: HowWeWorkCard[];
  // Color settings
  backgroundColorType?:
    | 'default'
    | 'primary'
    | 'secondary'
    | 'accent'
    | 'custom';
  backgroundColorShade?: number;
  backgroundCustomColor?: ColorData;
  accentColorType?: 'primary' | 'secondary' | 'accent' | 'custom';
  accentCustomColor?: ColorData;
  textColor?: 'base' | 'contrast';
}

const {
  title,
  description,
  cards,
  backgroundColorType = 'default',
  backgroundColorShade = 0,
  backgroundCustomColor,
  accentColorType = 'secondary',
  accentCustomColor,
  textColor = 'base',
} = Astro.props;

// Fetch site settings for colors
const settings = await client.fetch(siteSettingsQuery);
const siteColors = settings?.colors;

// Resolve background color (null if default)
const backgroundColor =
  backgroundColorType === 'default' || !backgroundColorType
    ? null
    : resolveColorSelection(
        {
          colorType: backgroundColorType,
          shade: backgroundColorShade,
          customColor: backgroundCustomColor,
        },
        siteColors
      );

// Resolve accent color (no shade)
const accentColor = resolveColorSelection(
  {
    colorType: accentColorType,
    customColor: accentCustomColor,
  },
  siteColors
);

// Define CSS variables for dynamic colors
const cssVars: Record<string, string> = {
  '--hww-accent': accentColor,
  '--hww-title-color':
    textColor === 'contrast' ? 'var(--color-text-contrast)' : accentColor,
  '--hww-text':
    textColor === 'contrast'
      ? 'var(--color-text-contrast)'
      : 'var(--color-text)',
  '--hww-text-muted':
    textColor === 'contrast'
      ? 'var(--color-text-contrast)'
      : 'var(--color-text-muted)',
};

// Only set background if not default
if (backgroundColor) {
  cssVars['--hww-bg'] = backgroundColor;
}

const cssVarsString = Object.entries(cssVars)
  .map(([key, value]) => `${key}: ${value}`)
  .join('; ');
---

<section class="how-we-work-section" style={cssVarsString}>
  <div class="container">
    <div class="how-we-work-section__header">
      <SectionTitle>{title}</SectionTitle>
      {
        description && (
          <p class="how-we-work-section__description">{description}</p>
        )
      }
    </div>

    <div class="timeline">
      {/* SVG will be generated by JavaScript at runtime */}
      <svg class="timeline__svg" aria-hidden="true">
        <path
          class="timeline__path"
          fill="none"
          stroke-width="3"
          stroke-linecap="round"
          stroke-linejoin="round"></path>
      </svg>
      {
        cards.map((card, index) => (
          <div class="timeline__item" style={`--item-index: ${index}`}>
            <div class="timeline__marker">
              <span class="timeline__number">
                {(index + 1).toString().padStart(2, '0')}
              </span>
            </div>
            <div class="timeline__content">
              <h3 class="timeline__title">{card.title}</h3>
              <p class="timeline__description">{card.description}</p>
            </div>
          </div>
        ))
      }
    </div>
  </div>
</section>

<style>
  .how-we-work-section {
    --hww-marker-size: 80px;
    --hww-number-size: clamp(1.75rem, 4vw, 2.5rem);
    /* Minimal vertical gap for almost horizontal line */
    --hww-item-gap: clamp(1rem, 2vw, 1.5rem);
    --hww-base-indent: 1rem;

    position: relative;
    padding: var(--space-3xl) 0;
    background: var(--hww-bg, var(--color-background));
    overflow: hidden;
  }

  /* Subtle paper texture overlay */
  .how-we-work-section::before {
    content: '';
    position: absolute;
    inset: 0;
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
    opacity: 0.08;
    pointer-events: none;
    z-index: 0;
  }

  /* Soft vertical gradient */
  .how-we-work-section::after {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(
      to bottom,
      transparent 0%,
      rgba(0, 0, 0, 0.05) 50%,
      transparent 100%
    );
    pointer-events: none;
    z-index: 0;
  }

  .how-we-work-section > .container {
    position: relative;
    z-index: 1;
  }

  /* Override section title color based on text color setting */
  .how-we-work-section :global(.section-title) {
    color: var(--hww-title-color, var(--color-accent));
  }

  .how-we-work-section__header {
    text-align: center;
    margin-block-end: var(--space-2xl);
  }

  .how-we-work-section__description {
    font-size: var(--font-size-lg);
    max-width: 600px;
    margin-inline: auto;
    color: var(--hww-text-muted, var(--color-text-muted));
  }

  .timeline {
    position: relative;
    /* Full width for maximum horizontal spread */
    max-width: 100%;
    margin-inline: auto;
    padding-inline: 2rem;
  }

  .timeline__svg {
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    z-index: 0;
    overflow: visible;
  }

  .timeline__path {
    stroke: var(--hww-accent, var(--color-secondary));
    stroke-width: 2px;
    opacity: 0;
    fill: none;
  }

  .timeline__item {
    display: flex;
    flex-direction: row;
    align-items: flex-start;
    gap: var(--hww-base-indent, 1rem);
    position: relative;
    padding-bottom: var(--hww-item-gap);
    max-width: 350px;
  }

  /* Diagonal Staggered Layout for Desktop - FLAT diagonal */
  @media (min-width: 768px) {
    .timeline {
      /* Use flex with controlled spacing for equidistant cards */
      display: flex;
      flex-direction: row;
      align-items: flex-start;
      justify-content: space-between;
      gap: 2rem;
      /* No extra padding - let section padding handle spacing */
      padding-top: 0;
    }

    .timeline__item {
      /* Stack vertically: circle on top, text below */
      flex-direction: column;
      /* Center circle horizontally */
      align-items: center;
      /* Remove margin-inline-start since we're using flex spacing */
      margin-inline-start: 0;
      /* Completely flat - no vertical offset */
      margin-top: 0;
      max-width: 280px;
      flex: 1;
      /* Remove bottom padding */
      padding-bottom: 0;
    }

    .timeline__content {
      padding-top: 0.75rem;
      /* Center text */
      text-align: center;
    }

    .timeline__title {
      text-align: center;
    }

    .timeline__description {
      text-align: center;
    }
  }

  .timeline__item:last-child {
    padding-bottom: 0;
  }

  .timeline__marker {
    position: relative;
    z-index: 2;
    display: flex;
    align-items: center;
    justify-content: center;
    width: var(--hww-marker-size);
    height: var(--hww-marker-size);
    min-width: var(--hww-marker-size);
    border-radius: 50%;
    background-color: var(--hww-bg, var(--color-background));
    border: 1.5px solid var(--hww-accent, var(--color-secondary));
    box-shadow:
      inset 0 0 0 3px var(--hww-bg, var(--color-background)),
      inset 0 0 0 4.5px
        color-mix(
          in srgb,
          var(--hww-accent, var(--color-secondary)) 30%,
          transparent
        );
    transform-origin: center;
  }

  .timeline__number {
    font-family: var(--font-heading);
    font-size: var(--hww-number-size);
    font-weight: 400;
    font-style: italic;
    letter-spacing: -0.02em;
    color: var(--hww-text, var(--color-text));
    /* Compensate for italic slant pushing text right */
    margin-left: -0.1em;
  }

  .timeline__content {
    padding-top: 1rem;
    flex: 1;
  }

  .timeline__title {
    font-size: var(--font-size-2xl);
    font-weight: var(--font-weight-semibold);
    margin: 0 0 0.75rem;
    font-family: var(--font-heading);
    font-style: italic;
    color: var(--hww-text, var(--color-text));
  }

  .timeline__description {
    font-size: var(--font-size-sm);
    color: var(--hww-text-muted, var(--color-text-muted));
    line-height: 1.7;
    margin: 0;
    opacity: 0.85;
  }

  /* Mobile: Reset to horizontal row stack */
  @media (max-width: 767px) {
    .how-we-work-section {
      --hww-marker-size: 65px;
      --hww-item-gap: clamp(2.5rem, 5vw, 3.5rem);
    }

    .timeline {
      padding-inline-start: 0;
      max-width: 650px;
    }

    .timeline__svg {
      /* Reset to default full coverage */
      left: 0;
      width: 100%;
    }

    .timeline__item {
      /* Reset to horizontal layout on mobile */
      flex-direction: row;
      margin-inline-start: 0;
      gap: 1.5rem;
      max-width: 100%;
    }
  }
</style>

<script>
  import { setupAnimationLifecycle, gsap } from '@lib/animation';

  function generateHorizontalPath(points: { x: number; y: number }[]): string {
    if (points.length < 2) return '';

    const firstPoint = points[0];
    if (!firstPoint) return '';
    let path = `M ${firstPoint.x} ${firstPoint.y}`;

    for (let i = 0; i < points.length - 1; i++) {
      const start = points[i];
      const end = points[i + 1];
      if (!start || !end) continue;

      const distX = end.x - start.x;

      // Add vertical amplitude for smooth waves
      const amplitude = 60;

      // Alternate wave direction for each segment
      const direction = i % 2 === 0 ? 1 : -1;

      // Control points at 1/3 and 2/3 of horizontal distance
      const cp1 = {
        x: start.x + distX * 0.33,
        y: (start.y + end.y) / 2 + amplitude * direction,
      };

      const cp2 = {
        x: start.x + distX * 0.66,
        y: (start.y + end.y) / 2 + amplitude * direction,
      };

      path += ` C ${cp1.x} ${cp1.y}, ${cp2.x} ${cp2.y}, ${end.x} ${end.y}`;
    }

    return path;
  }

  function initTimelinePath() {
    const timeline = document.querySelector('.timeline') as HTMLElement;
    const svg = document.querySelector('.timeline__svg') as SVGSVGElement;
    const path = document.querySelector('.timeline__path') as SVGPathElement;
    const markers = document.querySelectorAll('.timeline__marker');

    if (!timeline || !svg || !path || markers.length < 2) return;

    // Get the timeline's position for relative calculations
    const timelineRect = timeline.getBoundingClientRect();

    // Set SVG dimensions to match timeline exactly
    const svgWidth = timelineRect.width;
    const svgHeight = timelineRect.height;

    svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);

    // Get SIDE positions of each marker (right edge to left edge connection)
    const markerPositions: { x: number; y: number }[] = [];
    markers.forEach((marker, index) => {
      const rect = marker.getBoundingClientRect();
      const centerY = rect.top + rect.height / 2 - timelineRect.top;

      if (index === 0) {
        // First marker: use right edge
        const rightEdgeX = rect.right - timelineRect.left;
        markerPositions.push({ x: rightEdgeX, y: centerY });
      } else if (index === markers.length - 1) {
        // Last marker: use left edge
        const leftEdgeX = rect.left - timelineRect.left;
        markerPositions.push({ x: leftEdgeX, y: centerY });
      } else {
        // Middle markers: use both edges (right for incoming, left for outgoing)
        // For the path, we use left edge (where line arrives)
        const leftEdgeX = rect.left - timelineRect.left;
        markerPositions.push({ x: leftEdgeX, y: centerY });
      }
    });

    // Generate and set the path
    const pathD = generateHorizontalPath(markerPositions);
    path.setAttribute('d', pathD);

    return path;
  }

  setupAnimationLifecycle(() => {
    const timeline = document.querySelector('.timeline') as HTMLElement;
    if (!timeline) return;

    // Mobile check - disable draggable on small screens
    const isMobile = window.matchMedia('(max-width: 768px)').matches;

    // Function to run path calculation
    const updatePath = () => {
      // Small safety check to ensure element is still in DOM
      if (!timeline.isConnected) return;
      const path = initTimelinePath();

      // Update stroke-dasharray to accommodate new length
      // This prevents the line from "breaking" or showing gaps if stretched beyond original length
      if (path) {
        const len = path.getTotalLength();
        path.style.strokeDasharray = `${len}`;
        // Preserve hidden state - only set if not already animated
        // Check if strokeDashoffset is unset or needs initialization
        if (
          !path.style.strokeDashoffset ||
          path.style.strokeDashoffset === '0'
        ) {
          path.style.strokeDashoffset = `${len}`;
        }
      }
    };

    // Initial calculation (Synchronous) to ensure GSAP gets correct length
    // We still keep the ResizeObserver/Timeout for layout shifts
    if (timeline.isConnected) {
      const path = initTimelinePath();
      // Hide path immediately after initialization to prevent flash
      if (path) {
        const len = path.getTotalLength();
        path.style.strokeDasharray = `${len}`;
        path.style.strokeDashoffset = `${len}`;
      }
    }

    // Initial calculation with a small delay to ensure layout is settled
    // (Resolves potential race conditions with fonts/styles)
    setTimeout(updatePath, 100);

    // Use ResizeObserver for robust layout tracking
    const observer = new ResizeObserver(() => {
      // Debounce slightly to avoid thrashing
      requestAnimationFrame(() => updatePath());
    });
    observer.observe(timeline);

    // Initial Animation Setup - delay to ensure path is fully rendered
    setTimeout(() => {
      const section = document.querySelector(
        '.how-we-work-section'
      ) as HTMLElement;
      const path = timeline.querySelector(
        '.timeline__svg path'
      ) as SVGPathElement;

      if (path && section) {
        // Get the total length of the SVG path
        const pathLength = path.getTotalLength();

        // Set up stroke-dasharray and initial dashoffset
        path.style.strokeDasharray = `${pathLength}`;
        path.style.strokeDashoffset = `${pathLength}`;

        const markers = document.querySelectorAll('.timeline__marker');
        const contents = document.querySelectorAll('.timeline__content');
        const numMarkers = markers.length;

        if (numMarkers < 2) return;

        // ===== MOBILE: Use viewport-based triggers (no pinning) =====
        if (isMobile) {
          markers.forEach((marker, index) => {
            gsap.fromTo(
              marker,
              { scale: 0 },
              {
                scale: 1,
                ease: 'back.out(1.5)',
                scrollTrigger: {
                  trigger: marker,
                  start: 'top 75%',
                  end: 'top 55%',
                  scrub: 0.5,
                },
              }
            );

            const content = contents[index];
            if (content) {
              gsap.fromTo(
                content,
                { opacity: 0, x: -15 },
                {
                  opacity: 1,
                  x: 0,
                  ease: 'power2.out',
                  scrollTrigger: {
                    trigger: marker,
                    start: 'top 70%',
                    end: 'top 50%',
                    scrub: 0.5,
                  },
                }
              );
            }

            if (index < numMarkers - 1) {
              const nextMarker = markers[index + 1] as HTMLElement;
              if (!nextMarker) return;

              const segmentStart = pathLength * (1 - index / (numMarkers - 1));
              const segmentEnd =
                pathLength * (1 - (index + 1) / (numMarkers - 1));

              // First segment: no fade, just draw
              if (index === 0) {
                // Set opacity directly, no fade
                gsap.set(path, {
                  opacity: 0.6,
                  strokeDashoffset: segmentStart,
                });

                // Segment drawing animation
                gsap.to(path, {
                  strokeDashoffset: segmentEnd,
                  ease: 'none',
                  scrollTrigger: {
                    trigger: marker,
                    start: 'top 50%',
                    end: () => {
                      const nextRect = nextMarker.getBoundingClientRect();
                      const currentRect = marker.getBoundingClientRect();
                      return `+=${Math.abs(nextRect.top - currentRect.top) - 50}`;
                    },
                    scrub: 1,
                  },
                });
              } else {
                gsap.fromTo(
                  path,
                  { strokeDashoffset: segmentStart },
                  {
                    strokeDashoffset: segmentEnd,
                    ease: 'none',
                    immediateRender: false,
                    scrollTrigger: {
                      trigger: marker,
                      start: 'top 55%',
                      end: () => {
                        const nextRect = nextMarker.getBoundingClientRect();
                        const currentRect = marker.getBoundingClientRect();
                        return `+=${Math.abs(nextRect.top - currentRect.top) - 50}`;
                      },
                      scrub: 1,
                    },
                  }
                );
              }
            }
          });
        } else {
          // ===== DESKTOP: Two-phase approach with pinning =====

          const firstMarker = markers[0] as HTMLElement;
          const firstContent = contents[0];
          const remainingMarkers = Array.from(markers).slice(
            1
          ) as HTMLElement[];
          const remainingContents = Array.from(contents).slice(1);

          // PHASE 1: First card uses viewport-based triggers (pre-pin)
          gsap.fromTo(
            firstMarker,
            { scale: 0 },
            {
              scale: 1,
              ease: 'back.out(1.5)',
              scrollTrigger: {
                trigger: firstMarker,
                start: 'top 75%',
                end: 'top 55%',
                scrub: 0.5,
              },
            }
          );

          if (firstContent) {
            gsap.fromTo(
              firstContent,
              { opacity: 0, x: -15 },
              {
                opacity: 1,
                x: 0,
                ease: 'power2.out',
                scrollTrigger: {
                  trigger: firstMarker,
                  start: 'top 70%',
                  end: 'top 50%',
                  scrub: 0.5,
                },
              }
            );
          }

          // First path segment (from first to second marker) - also pre-pin
          if (numMarkers > 1) {
            const secondMarker = markers[1] as HTMLElement;
            const segmentStart = pathLength; // Full path hidden
            const segmentEnd = pathLength * (1 - 1 / (numMarkers - 1));

            // No fade - set opacity directly, just draw the segment
            gsap.set(path, { opacity: 0.6, strokeDashoffset: segmentStart });

            // Segment drawing animation
            gsap.to(path, {
              strokeDashoffset: segmentEnd,
              ease: 'none',
              scrollTrigger: {
                trigger: firstMarker,
                start: 'top 50%',
                end: () => {
                  const nextRect = secondMarker.getBoundingClientRect();
                  const currentRect = firstMarker.getBoundingClientRect();
                  return `+=${Math.abs(nextRect.top - currentRect.top) - 50}`;
                },
                scrub: 1,
              },
            });
          }

          // PHASE 2: Remaining cards reveal during pinned state
          if (remainingMarkers.length > 0) {
            const scrollPerCard = 300; // Scroll distance per card reveal
            const pinDuration = remainingMarkers.length * scrollPerCard;
            const timePerCard = 1 / remainingMarkers.length;

            // Create pinned timeline
            const pinnedTimeline = gsap.timeline({
              scrollTrigger: {
                trigger: section,
                start: 'top top',
                end: `+=${pinDuration}`,
                pin: true,
                pinSpacing: true,
                scrub: 1,
                anticipatePin: 1,
              },
            });

            // Add remaining cards to pinned timeline
            remainingMarkers.forEach((marker, relativeIndex) => {
              const absoluteIndex = relativeIndex + 1;
              const content = remainingContents[relativeIndex];
              const startTime = relativeIndex * timePerCard;

              // Marker scale animation
              pinnedTimeline.fromTo(
                marker,
                { scale: 0 },
                {
                  scale: 1,
                  ease: 'back.out(1.5)',
                  duration: timePerCard * 0.5,
                },
                startTime
              );

              // Content fade animation
              if (content) {
                pinnedTimeline.fromTo(
                  content,
                  { opacity: 0, x: -15 },
                  {
                    opacity: 1,
                    x: 0,
                    ease: 'power2.out',
                    duration: timePerCard * 0.6,
                  },
                  startTime + timePerCard * 0.15
                );
              }

              // SVG path segment (if not last marker)
              if (absoluteIndex < numMarkers - 1) {
                const segmentStart =
                  pathLength * (1 - absoluteIndex / (numMarkers - 1));
                const segmentEnd =
                  pathLength * (1 - (absoluteIndex + 1) / (numMarkers - 1));

                pinnedTimeline.fromTo(
                  path,
                  { strokeDashoffset: segmentStart },
                  {
                    strokeDashoffset: segmentEnd,
                    ease: 'none',
                    duration: timePerCard * 0.8,
                    immediateRender: false,
                  },
                  startTime + timePerCard * 0.2
                );
              }
            });
          }
        }
      }
    }, 500); // Delay to ensure path is fully rendered before animation setup
  });
</script>
