---
import SectionTitle from '@components/ui/SectionTitle.astro';
import { resolveColorSelection } from '@lib/sanity/colorResolver';
import { sanityClient as client } from 'sanity:client';
import { siteSettingsQuery } from '@lib/sanity/queries';

interface ColorData {
  label?: string;
  value: string;
}

interface HowWeWorkCard {
  _key: string;
  title: string;
  description: string;
}

interface Props {
  title: string;
  description?: string;
  cards: HowWeWorkCard[];
  // Color settings
  backgroundColorType?:
    | 'default'
    | 'primary'
    | 'secondary'
    | 'accent'
    | 'custom';
  backgroundColorShade?: number;
  backgroundCustomColor?: ColorData;
  accentColorType?: 'primary' | 'secondary' | 'accent' | 'custom';
  accentColorShade?: number;
  accentCustomColor?: ColorData;
  textColor?: 'base' | 'contrast';
}

const {
  title,
  description,
  cards,
  backgroundColorType = 'default',
  backgroundColorShade = 0,
  backgroundCustomColor,
  accentColorType = 'secondary',
  accentColorShade = 0,
  accentCustomColor,
  textColor = 'base',
} = Astro.props;

// Fetch site settings for colors
const settings = await client.fetch(siteSettingsQuery);
const siteColors = settings?.colors;

// Resolve background color (null if default)
const backgroundColor =
  backgroundColorType === 'default' || !backgroundColorType
    ? null
    : resolveColorSelection(
        {
          colorType: backgroundColorType,
          shade: backgroundColorShade,
          customColor: backgroundCustomColor,
        },
        siteColors
      );

// Resolve accent color
const accentColor = resolveColorSelection(
  {
    colorType: accentColorType,
    shade: accentColorShade,
    customColor: accentCustomColor,
  },
  siteColors
);

// Define CSS variables for dynamic colors
const cssVars: Record<string, string> = {
  '--hww-accent': accentColor,
  '--hww-text':
    textColor === 'contrast'
      ? 'var(--color-text-contrast)'
      : 'var(--color-text)',
  '--hww-text-muted':
    textColor === 'contrast'
      ? 'var(--color-text-contrast)'
      : 'var(--color-text-muted)',
};

// Only set background if not default
if (backgroundColor) {
  cssVars['--hww-bg'] = backgroundColor;
}

const cssVarsString = Object.entries(cssVars)
  .map(([key, value]) => `${key}: ${value}`)
  .join('; ');
---

<section class="how-we-work-section" style={cssVarsString}>
  <div class="container">
    <div class="how-we-work-section__header">
      <SectionTitle>{title}</SectionTitle>
      {
        description && (
          <p class="how-we-work-section__description">{description}</p>
        )
      }
    </div>

    <div class="timeline">
      {/* SVG will be generated by JavaScript at runtime */}
      <svg class="timeline__svg" aria-hidden="true">
        <path
          class="timeline__path"
          fill="none"
          stroke-width="2"
          stroke-linecap="round"
          stroke-linejoin="round"></path>
      </svg>
      {
        cards.map((card, index) => (
          <div class="timeline__item">
            <div class="timeline__marker">
              <span class="timeline__number">
                {(index + 1).toString().padStart(2, '0')}
              </span>
            </div>
            <div class="timeline__content">
              <h3 class="timeline__title">{card.title}</h3>
              <p class="timeline__description">{card.description}</p>
            </div>
          </div>
        ))
      }
    </div>
  </div>
</section>

<style>
  .how-we-work-section {
    padding: var(--space-2xl) 0;
    background: var(--hww-bg, var(--color-background));
  }

  .how-we-work-section__header {
    text-align: center;
    margin-block-end: var(--space-xl);
  }

  .how-we-work-section__description {
    font-size: var(--font-size-lg);
    max-width: 600px;
    margin-inline: auto;
    color: var(--hww-text-muted, var(--color-text-muted));
  }

  .timeline {
    position: relative;
    max-width: 600px;
    margin-inline: auto;
  }

  .timeline__svg {
    position: absolute;
    left: 0;
    top: 0;
    width: 60px;
    height: 100%;
    z-index: 0;
    overflow: visible;
  }

  .timeline__path {
    stroke: var(--hww-accent, var(--color-secondary));
  }

  .timeline__item {
    display: flex;
    flex-direction: row;
    align-items: flex-start;
    gap: 1.5rem;
    position: relative;
    padding-bottom: 2.5rem;
  }

  .timeline__item:last-child {
    padding-bottom: 0;
  }

  .timeline__marker {
    position: relative;
    z-index: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 60px;
    height: 60px;
    min-width: 60px;
    border-radius: 50%;
    background-color: var(--hww-bg, var(--color-background));
    border: 2px solid var(--hww-accent, var(--color-secondary));
  }

  .timeline__number {
    font-family: var(--font-heading);
    font-size: 1.125rem;
    font-weight: 500;
    color: var(--hww-text, var(--color-text));
  }

  .timeline__content {
    padding-top: 0.75rem;
    flex: 1;
  }

  .timeline__title {
    font-size: var(--font-size-xl);
    font-weight: var(--font-weight-semibold);
    margin: 0 0 0.5rem;
    font-family: var(--font-heading);
    font-style: italic;
    color: var(--hww-text, var(--color-text));
  }

  .timeline__description {
    font-size: var(--font-size-base);
    color: var(--hww-text-muted, var(--color-text-muted));
    line-height: 1.6;
    margin: 0;
  }

  @media (max-width: 480px) {
    .timeline__svg {
      width: 50px;
    }

    .timeline__item {
      gap: 1rem;
    }

    .timeline__marker {
      width: 50px;
      height: 50px;
      min-width: 50px;
    }
  }
</style>

<script>
  import {
    setupAnimationLifecycle,
    gsap,
    ANIMATION_CONFIG,
  } from '@lib/animation';

  function generateWavyPath(markerCenters: number[], svgWidth: number): string {
    if (markerCenters.length < 2) return '';

    const centerX = svgWidth / 2;
    const amplitude = 15; // How far the wave bulges left/right

    let path = `M ${centerX} ${markerCenters[0]}`;

    for (let i = 0; i < markerCenters.length - 1; i++) {
      const startY = markerCenters[i];
      const endY = markerCenters[i + 1];
      const midY = (startY + endY) / 2;

      // Alternate direction: even segments curve right, odd curve left
      const direction = i % 2 === 0 ? 1 : -1;
      const curveX = centerX + amplitude * direction;

      // Create S-curve using cubic bezier
      // First half: from start to midpoint, curving outward
      path += ` C ${centerX} ${startY + (midY - startY) * 0.3}, ${curveX} ${startY + (midY - startY) * 0.5}, ${curveX} ${midY}`;
      // Second half: from midpoint to end, curving back to center
      path += ` C ${curveX} ${midY + (endY - midY) * 0.5}, ${centerX} ${midY + (endY - midY) * 0.7}, ${centerX} ${endY}`;
    }

    return path;
  }

  function initTimelinePath() {
    const timeline = document.querySelector('.timeline') as HTMLElement;
    const svg = document.querySelector('.timeline__svg') as SVGSVGElement;
    const path = document.querySelector('.timeline__path') as SVGPathElement;
    const markers = document.querySelectorAll('.timeline__marker');

    if (!timeline || !svg || !path || markers.length < 2) return;

    // Get the timeline's position for relative calculations
    const timelineRect = timeline.getBoundingClientRect();

    // Get center Y position of each marker relative to the timeline
    const markerCenters: number[] = [];
    markers.forEach((marker) => {
      const rect = marker.getBoundingClientRect();
      const centerY = rect.top + rect.height / 2 - timelineRect.top;
      markerCenters.push(centerY);
    });

    // Calculate SVG dimensions
    const svgWidth = 60; // Match CSS width
    const svgHeight = timelineRect.height;

    // Set viewBox to match actual pixel dimensions
    svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);

    // Generate and set the path
    const pathD = generateWavyPath(markerCenters, svgWidth);
    path.setAttribute('d', pathD);

    return path;
  }

  setupAnimationLifecycle(() => {
    // Initialize the path after DOM is ready
    const path = initTimelinePath();

    if (path) {
      // Get the total length of the SVG path
      const pathLength = path.getTotalLength();

      // Set up stroke-dasharray and initial dashoffset
      path.style.strokeDasharray = `${pathLength}`;
      path.style.strokeDashoffset = `${pathLength}`;

      // Animate the path drawing on scroll - starts AFTER items begin appearing
      gsap.to(path, {
        strokeDashoffset: 0,
        ease: 'none',
        scrollTrigger: {
          trigger: '.timeline',
          start: 'top 65%',
          end: 'bottom 50%',
          scrub: true,
        },
      });
    }

    // Staggered item reveal - starts BEFORE line animation
    gsap.fromTo(
      '.timeline__item',
      { opacity: 0, y: 40 },
      {
        opacity: 1,
        y: 0,
        stagger: 0.2,
        ease: ANIMATION_CONFIG.ease.reveal,
        scrollTrigger: {
          trigger: '.timeline',
          start: 'top 85%',
          end: 'bottom 55%',
          scrub: 1,
        },
      }
    );
  });
</script>
