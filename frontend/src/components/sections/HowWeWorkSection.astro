---
import SectionTitle from '@components/ui/SectionTitle.astro';
import { resolveColorSelection } from '@lib/sanity/colorResolver';
import { sanityClient as client } from 'sanity:client';
import { siteSettingsQuery } from '@lib/sanity/queries';

interface ColorData {
  label?: string;
  value: string;
}

interface HowWeWorkCard {
  _key: string;
  title: string;
  description: string;
}

interface Props {
  title: string;
  description?: string;
  cards: HowWeWorkCard[];
  // Color settings
  backgroundColorType?:
    | 'default'
    | 'primary'
    | 'secondary'
    | 'accent'
    | 'custom';
  backgroundColorShade?: number;
  backgroundCustomColor?: ColorData;
  accentColorType?: 'primary' | 'secondary' | 'accent' | 'custom';
  accentCustomColor?: ColorData;
  textColor?: 'base' | 'contrast';
}

const {
  title,
  description,
  cards,
  backgroundColorType = 'default',
  backgroundColorShade = 0,
  backgroundCustomColor,
  accentColorType = 'secondary',
  accentCustomColor,
  textColor = 'base',
} = Astro.props;

// Fetch site settings for colors
const settings = await client.fetch(siteSettingsQuery);
const siteColors = settings?.colors;

// Resolve background color (null if default)
const backgroundColor =
  backgroundColorType === 'default' || !backgroundColorType
    ? null
    : resolveColorSelection(
        {
          colorType: backgroundColorType,
          shade: backgroundColorShade,
          customColor: backgroundCustomColor,
        },
        siteColors
      );

// Resolve accent color (no shade)
const accentColor = resolveColorSelection(
  {
    colorType: accentColorType,
    customColor: accentCustomColor,
  },
  siteColors
);

// Define CSS variables for dynamic colors
const cssVars: Record<string, string> = {
  '--hww-accent': accentColor,
  '--hww-text':
    textColor === 'contrast'
      ? 'var(--color-text-contrast)'
      : 'var(--color-text)',
  '--hww-text-muted':
    textColor === 'contrast'
      ? 'var(--color-text-contrast)'
      : 'var(--color-text-muted)',
};

// Only set background if not default
if (backgroundColor) {
  cssVars['--hww-bg'] = backgroundColor;
}

const cssVarsString = Object.entries(cssVars)
  .map(([key, value]) => `${key}: ${value}`)
  .join('; ');
---

<section class="how-we-work-section" style={cssVarsString}>
  <div class="container">
    <div class="how-we-work-section__header">
      <SectionTitle>{title}</SectionTitle>
      {
        description && (
          <p class="how-we-work-section__description">{description}</p>
        )
      }
    </div>

    <div class="timeline">
      {/* SVG will be generated by JavaScript at runtime */}
      <svg class="timeline__svg" aria-hidden="true">
        <path
          class="timeline__path"
          fill="none"
          stroke-width="3"
          stroke-linecap="round"
          stroke-linejoin="round"></path>
      </svg>
      {
        cards.map((card, index) => (
          <div class="timeline__item" style={`--item-index: ${index}`}>
            <div class="timeline__marker">
              <span class="timeline__number">
                {(index + 1).toString().padStart(2, '0')}
              </span>
            </div>
            <div class="timeline__content">
              <h3 class="timeline__title">{card.title}</h3>
              <p class="timeline__description">{card.description}</p>
            </div>
          </div>
        ))
      }
    </div>
  </div>
</section>

<style>
  .how-we-work-section {
    --hww-marker-size: 80px;
    --hww-number-size: clamp(1.75rem, 4vw, 2.5rem);
    --hww-item-gap: clamp(3rem, 6vw, 5rem);
    --hww-base-indent: 2rem;
    --hww-indent-step: 3rem;

    position: relative;
    padding: var(--space-3xl) 0;
    background: var(--hww-bg, var(--color-background));
    overflow: hidden;
  }

  /* Subtle paper texture overlay */
  .how-we-work-section::before {
    content: '';
    position: absolute;
    inset: 0;
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
    opacity: 0.08;
    pointer-events: none;
    z-index: 0;
  }

  /* Soft vertical gradient */
  .how-we-work-section::after {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(
      to bottom,
      transparent 0%,
      rgba(0, 0, 0, 0.05) 50%,
      transparent 100%
    );
    pointer-events: none;
    z-index: 0;
  }

  .how-we-work-section > .container {
    position: relative;
    z-index: 1;
  }

  .how-we-work-section__header {
    text-align: center;
    margin-block-end: var(--space-2xl);
  }

  .how-we-work-section__description {
    font-size: var(--font-size-lg);
    max-width: 600px;
    margin-inline: auto;
    color: var(--hww-text-muted, var(--color-text-muted));
  }

  .timeline {
    position: relative;
    max-width: 650px;
    margin-inline: auto;
    padding-inline-start: 1rem;
  }

  .timeline__svg {
    position: absolute;
    left: calc(1rem - 30px); /* Offset to center wider canvas over markers */
    top: 0;
    width: 140px; /* Wider canvas for more organic curves */
    height: 100%;
    z-index: 0;
    overflow: visible;
  }

  .timeline__path {
    stroke: var(--hww-accent, var(--color-secondary));
    opacity: 0.85;
  }

  .timeline__item {
    --item-indent: calc(
      var(--hww-base-indent) + var(--hww-indent-step) * var(--item-index, 0)
    );

    display: flex;
    flex-direction: row;
    align-items: flex-start;
    gap: var(--item-indent);
    position: relative;
    padding-bottom: var(--hww-item-gap);
  }

  .timeline__item:last-child {
    padding-bottom: 0;
  }

  .timeline__marker {
    position: relative;
    z-index: 2;
    display: flex;
    align-items: center;
    justify-content: center;
    width: var(--hww-marker-size);
    height: var(--hww-marker-size);
    min-width: var(--hww-marker-size);
    border-radius: 50%;
    background-color: var(--hww-bg, var(--color-background));
    border: 1.5px solid var(--hww-accent, var(--color-secondary));
    box-shadow:
      inset 0 0 0 3px var(--hww-bg, var(--color-background)),
      inset 0 0 0 4.5px
        color-mix(
          in srgb,
          var(--hww-accent, var(--color-secondary)) 30%,
          transparent
        );
    transform-origin: center;
  }

  .timeline__number {
    font-family: var(--font-heading);
    font-size: var(--hww-number-size);
    font-weight: 400;
    font-style: italic;
    letter-spacing: -0.02em;
    color: var(--hww-text, var(--color-text));
    /* Compensate for italic slant pushing text right */
    margin-left: -0.1em;
  }

  .timeline__content {
    padding-top: 1rem;
    flex: 1;
  }

  .timeline__title {
    font-size: var(--font-size-2xl);
    font-weight: var(--font-weight-semibold);
    margin: 0 0 0.75rem;
    font-family: var(--font-heading);
    font-style: italic;
    color: var(--hww-text, var(--color-text));
  }

  .timeline__description {
    font-size: var(--font-size-sm);
    color: var(--hww-text-muted, var(--color-text-muted));
    line-height: 1.7;
    margin: 0;
    opacity: 0.85;
  }

  @media (max-width: 480px) {
    .how-we-work-section {
      --hww-marker-size: 65px;
      --hww-item-gap: clamp(2.5rem, 5vw, 3.5rem);
      --hww-indent-step: 1rem;
    }

    .timeline {
      padding-inline-start: 0;
    }

    .timeline__svg {
      left: -17.5px; /* Center 100px canvas over 65px marker: (100-65)/2 = 17.5 */
      width: 100px;
    }

    .timeline__item {
      gap: calc(
        var(--hww-base-indent) * 0.75 + var(--hww-indent-step) *
          var(--item-index, 0)
      );
    }
  }
</style>

<script>
  import { setupAnimationLifecycle, gsap } from '@lib/animation';

  function generateWavyPath(
    markerCenters: number[],
    svgWidth: number,
    isMobile: boolean
  ): string {
    if (markerCenters.length < 2) return '';

    const centerX = svgWidth / 2;
    const amplitude = isMobile ? 30 : 45; // How far the wave bulges left/right - dramatic organic sweep

    const firstCenter = markerCenters[0] ?? 0;
    let path = `M ${centerX} ${firstCenter}`;

    for (let i = 0; i < markerCenters.length - 1; i++) {
      const startY = markerCenters[i] ?? 0;
      const endY = markerCenters[i + 1] ?? 0;
      const midY = (startY + endY) / 2;

      // Alternate direction: even segments curve right, odd curve left
      const direction = i % 2 === 0 ? 1 : -1;
      const curveX = centerX + amplitude * direction;

      // Create S-curve using cubic bezier with more organic control points
      // First half: from start to midpoint, curving outward
      path += ` C ${centerX} ${startY + (midY - startY) * 0.25}, ${curveX} ${startY + (midY - startY) * 0.45}, ${curveX} ${midY}`;
      // Second half: from midpoint to end, curving back to center
      path += ` C ${curveX} ${midY + (endY - midY) * 0.55}, ${centerX} ${midY + (endY - midY) * 0.75}, ${centerX} ${endY}`;
    }

    return path;
  }

  function initTimelinePath() {
    const timeline = document.querySelector('.timeline') as HTMLElement;
    const svg = document.querySelector('.timeline__svg') as SVGSVGElement;
    const path = document.querySelector('.timeline__path') as SVGPathElement;
    const markers = document.querySelectorAll('.timeline__marker');

    if (!timeline || !svg || !path || markers.length < 2) return;

    // Get the timeline's position for relative calculations
    const timelineRect = timeline.getBoundingClientRect();

    // Get center Y position of each marker relative to the timeline
    const markerCenters: number[] = [];
    markers.forEach((marker) => {
      const rect = marker.getBoundingClientRect();
      const centerY = rect.top + rect.height / 2 - timelineRect.top;
      markerCenters.push(centerY);
    });

    // Calculate SVG dimensions - use fixed wider canvas for organic curves
    const isMobile = window.innerWidth <= 480;
    const svgWidth = isMobile ? 100 : 140; // Wider canvas allows more dramatic curves
    const svgHeight = timelineRect.height;

    // Set viewBox to match actual pixel dimensions
    svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);

    // Generate and set the path
    const pathD = generateWavyPath(markerCenters, svgWidth, isMobile);
    path.setAttribute('d', pathD);

    return path;
  }

  setupAnimationLifecycle(() => {
    // Initialize the path after DOM is ready
    const path = initTimelinePath();

    if (path) {
      // Get the total length of the SVG path
      const pathLength = path.getTotalLength();

      // Set up stroke-dasharray and initial dashoffset
      path.style.strokeDasharray = `${pathLength}`;
      path.style.strokeDashoffset = `${pathLength}`;

      const markers = document.querySelectorAll('.timeline__marker');
      const contents = document.querySelectorAll('.timeline__content');
      const numMarkers = markers.length;

      markers.forEach((marker, index) => {
        // Marker appears first
        gsap.fromTo(
          marker,
          { scale: 0 },
          {
            scale: 1,
            ease: 'back.out(1.5)',
            scrollTrigger: {
              trigger: marker,
              start: 'top 75%',
              end: 'top 55%',
              scrub: 0.5,
            },
          }
        );

        // Content follows marker
        const content = contents[index];
        if (content) {
          gsap.fromTo(
            content,
            { opacity: 0, x: -15 },
            {
              opacity: 1,
              x: 0,
              ease: 'power2.out',
              scrollTrigger: {
                trigger: marker,
                start: 'top 70%',
                end: 'top 50%',
                scrub: 0.5,
              },
            }
          );
        }

        // Path segment grows OUT OF this marker AFTER it appears
        // (except for last marker - no segment after it)
        if (index < numMarkers - 1) {
          const nextMarker = markers[index + 1] as HTMLElement;
          if (!nextMarker) return;

          // Calculate segment start and end points
          const segmentStart = pathLength * (1 - index / (numMarkers - 1));
          const segmentEnd = pathLength * (1 - (index + 1) / (numMarkers - 1));

          gsap.fromTo(
            path,
            { strokeDashoffset: segmentStart },
            {
              strokeDashoffset: segmentEnd,
              ease: 'none',
              immediateRender: false,
              scrollTrigger: {
                trigger: marker,
                start: 'top 55%', // Start AFTER marker is revealed
                end: () => {
                  // End when next marker starts appearing
                  const nextRect = nextMarker.getBoundingClientRect();
                  return `+=${nextRect.top - marker.getBoundingClientRect().top - 100}`;
                },
                scrub: 1,
              },
            }
          );
        }
      });
    }
  });
</script>
