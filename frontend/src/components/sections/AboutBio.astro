---
import { urlForImageWithSeoFilename } from '@lib/sanity/image';
import { resolveColorSelection } from '@lib/sanity/colorResolver';
import { sanityClient as client } from 'sanity:client';
import { siteSettingsQuery } from '@lib/sanity/queries';
import { Icon } from 'astro-icon/components';
import { PortableText } from 'astro-portabletext';
import Link from '@components/sanity/marks/Link.astro';
import PortraitImage from '@components/ui/PortraitImage.astro';

interface ImageAsset {
  _id: string;
  url: string;
  metadata?: {
    lqip?: string;
    dimensions?: {
      width: number;
      height: number;
      aspectRatio: number;
    };
  };
}

interface SanityImage {
  asset?: ImageAsset;
  alt?: string;
  seoFilename?: string;
  hotspot?: { x: number; y: number };
  crop?: { top: number; bottom: number; left: number; right: number };
}

interface ColorData {
  label?: string;
  value: string;
}

interface GradientColorData {
  colorType?: 'primary' | 'secondary' | 'accent' | 'custom';
  shade?: number;
  customColor?: ColorData;
}

interface GradientData {
  direction?: string;
  startColor?: GradientColorData;
  endColor?: GradientColorData;
}

interface BioBit {
  _key: string;
  icon?: { name: string };
  iconColorType?: 'primary' | 'secondary' | 'accent' | 'custom';
  iconColorShade?: number;
  iconCustomColor?: ColorData;
  title: string;
  titleColorType?: 'primary' | 'secondary' | 'accent' | 'custom';
  titleColorShade?: number;
  titleCustomColor?: ColorData;
  content?: any[];
}

interface Props {
  image?: SanityImage;
  overlayColorType?: 'primary' | 'secondary' | 'accent' | 'custom';
  overlayColorShade?: number;
  overlayCustomColor?: ColorData;
  label?: string;
  labelColorType?: 'primary' | 'secondary' | 'accent' | 'custom';
  labelColorShade?: number;
  labelCustomColor?: ColorData;
  name?: string;
  nameColorType?: 'primary' | 'secondary' | 'accent' | 'custom';
  nameColorShade?: number;
  nameCustomColor?: ColorData;
  backgroundColorType?:
    | 'default'
    | 'primary'
    | 'secondary'
    | 'accent'
    | 'custom';
  backgroundColorMode?: 'solid' | 'gradient';
  backgroundColorShade?: number;
  backgroundCustomColor?: ColorData;
  backgroundGradient?: GradientData;
  bioBits?: BioBit[];
}

const {
  image,
  overlayColorType = 'accent',
  overlayColorShade = 0,
  overlayCustomColor,
  label,
  labelColorType = 'accent',
  labelColorShade = 0,
  labelCustomColor,
  name,
  nameColorType = 'primary',
  nameColorShade = 0,
  nameCustomColor,
  backgroundColorType = 'default',
  backgroundColorMode = 'solid',
  backgroundColorShade = 95,
  backgroundCustomColor,
  backgroundGradient,
  bioBits = [],
} = Astro.props;

// Fetch site settings for colors
const settings = await client.fetch(siteSettingsQuery);
const siteColors = settings?.colors;

// Resolve background color
const backgroundColor =
  backgroundColorType === 'default'
    ? null
    : backgroundColorMode === 'gradient' && backgroundGradient
      ? `linear-gradient(${backgroundGradient.direction || '135deg'}, ${resolveColorSelection(backgroundGradient.startColor, siteColors)}, ${resolveColorSelection(backgroundGradient.endColor, siteColors)})`
      : resolveColorSelection(
          {
            colorType: backgroundColorType,
            shade: backgroundColorShade,
            customColor: backgroundCustomColor,
          },
          siteColors
        );

// Resolve label color
const labelColor = resolveColorSelection(
  {
    colorType: labelColorType,
    shade: labelColorShade,
    customColor: labelCustomColor,
  },
  siteColors
);

// Resolve name color
const nameColor = resolveColorSelection(
  {
    colorType: nameColorType,
    shade: nameColorShade,
    customColor: nameCustomColor,
  },
  siteColors
);

// Resolve overlay color for image
const overlayColor = resolveColorSelection(
  {
    colorType: overlayColorType,
    shade: overlayColorShade,
    customColor: overlayCustomColor,
  },
  siteColors
);

// Convert hex to RGB for rgba() usage
function hexToRgb(hex: string): { r: number; g: number; b: number } {
  const cleanHex = hex.replace('#', '');
  return {
    r: parseInt(cleanHex.substring(0, 2), 16),
    g: parseInt(cleanHex.substring(2, 4), 16),
    b: parseInt(cleanHex.substring(4, 6), 16),
  };
}

// Lighten a hex color by mixing with white
function lightenColor(hex: string, amount: number): string {
  const { r, g, b } = hexToRgb(hex);

  const newR = Math.round(r + (255 - r) * amount);
  const newG = Math.round(g + (255 - g) * amount);
  const newB = Math.round(b + (255 - b) * amount);

  const toHex = (n: number) =>
    Math.max(0, Math.min(255, n)).toString(16).padStart(2, '0');
  return `#${toHex(newR)}${toHex(newG)}${toHex(newB)}`;
}

// Helper to resolve icon colors for each card
function getCardIconColors(card: BioBit) {
  const iconColor =
    card.iconColorType === 'custom' && card.iconCustomColor?.value
      ? card.iconCustomColor.value
      : resolveColorSelection(
          {
            colorType: card.iconColorType || 'accent',
            shade: card.iconColorShade || 0,
            customColor: card.iconCustomColor,
          },
          siteColors
        );

  let iconBgColor: string;
  if (card.iconColorType === 'custom' && card.iconCustomColor?.value) {
    iconBgColor = lightenColor(card.iconCustomColor.value, 0.85);
  } else {
    iconBgColor = resolveColorSelection(
      {
        colorType: card.iconColorType || 'accent',
        shade: 90,
        customColor: card.iconCustomColor,
      },
      siteColors
    );
  }

  return { iconColor, iconBgColor };
}

// Helper to resolve title color for each card
function getCardTitleColor(card: BioBit): string {
  return card.titleColorType === 'custom' && card.titleCustomColor?.value
    ? card.titleCustomColor.value
    : resolveColorSelection(
        {
          colorType: card.titleColorType || 'accent',
          shade: card.titleColorShade || 0,
          customColor: card.titleCustomColor,
        },
        siteColors
      );
}

// Build overlay gradient
const overlayRgb = hexToRgb(overlayColor);
const overlayGradient = `linear-gradient(to top, rgba(${overlayRgb.r}, ${overlayRgb.g}, ${overlayRgb.b}, 0.75) 0%, rgba(${overlayRgb.r}, ${overlayRgb.g}, ${overlayRgb.b}, 0.4) 25%, transparent 50%)`;

const cssVars = [
  backgroundColor ? `--bio-bg: ${backgroundColor}` : null,
  `--bio-label-color: ${labelColor}`,
  `--bio-name-color: ${nameColor}`,
  `--bio-overlay-gradient: ${overlayGradient}`,
]
  .filter(Boolean)
  .join('; ');

// Generate image URL
const imageUrl = image?.asset
  ? urlForImageWithSeoFilename(
      image as {
        asset?: { _ref?: string };
        alt?: string;
        seoFilename?: string;
      },
      { width: 800, quality: 85 }
    )
  : null;

const imageLqip = image?.asset?.metadata?.lqip;
---

<section class="about-narrative" style={cssVars} data-animate>
  <div class="container">
    <div class="about-narrative__grid">
      {/* Left Column - Sticky Image with Overlay */}
      {
        imageUrl && (
          <div class="about-narrative__image-column">
            <PortraitImage
              src={imageUrl}
              alt={image?.alt || name || ''}
              lqip={imageLqip}
              hasOverlay={true}
              overlayGradient={overlayGradient}
              label={label}
              name={name}
            />
          </div>
        )
      }

      {/* Right Column - Scrollable Narrative Cards */}
      <div class="about-narrative__cards-column">
        {
          bioBits &&
            bioBits.length > 0 &&
            bioBits.map((card) => {
              const { iconColor, iconBgColor } = getCardIconColors(card);
              const titleColor = getCardTitleColor(card);
              const cardCssVars = [
                `--card-icon-color: ${iconColor}`,
                `--card-icon-bg: ${iconBgColor}`,
                `--card-title-color: ${titleColor}`,
              ].join('; ');

              return (
                <article class="about-narrative__card" style={cardCssVars}>
                  {card.icon?.name && (
                    <span class="about-narrative__card-icon-wrapper">
                      <Icon
                        name={card.icon.name}
                        class="about-narrative__card-icon"
                        aria-hidden="true"
                      />
                    </span>
                  )}
                  <div class="about-narrative__card-body">
                    <h3 class="about-narrative__card-title">{card.title}</h3>
                    {card.content && (
                      <div class="about-narrative__card-content">
                        <PortableText
                          value={card.content}
                          components={{ mark: { link: Link } }}
                        />
                      </div>
                    )}
                  </div>
                </article>
              );
            })
        }
      </div>
    </div>
  </div>
</section>

<style>
  .about-narrative {
    padding-block: var(--space-2xl);
    background: var(--bio-bg, transparent);
  }

  .about-narrative__grid {
    display: grid;
    grid-template-columns: 1fr;
    gap: var(--space-xl);
  }

  @media (min-width: 768px) {
    .about-narrative__grid {
      grid-template-columns: 1fr 1fr;
      gap: var(--space-2xl);
      align-items: start;
    }
  }

  /* ============================================
     LEFT COLUMN - Sticky Image with Overlay
     ============================================ */
  .about-narrative__image-column {
    position: relative;
  }

  /* Image column pinned via GSAP ScrollTrigger (CSS sticky breaks with Lenis) */
  @media (min-width: 768px) {
    .about-narrative__image-column {
      align-self: start;
    }
  }

  /* ============================================
     RIGHT COLUMN - Scrollable Narrative Cards
     ============================================ */
  .about-narrative__cards-column {
    display: flex;
    flex-direction: column;
    gap: var(--space-2xl);
  }

  .about-narrative__card {
    display: flex;
    align-items: flex-start;
    gap: 1rem;
    position: relative;
  }

  /* Vertical line connecting icons */
  .about-narrative__card::before {
    content: '';
    position: absolute;
    left: 1.5rem;
    top: 3.5rem;
    bottom: calc(-1 * var(--space-2xl) + 0.5rem);
    width: 2px;
    background-color: var(--color-border, #e5e5e5);
    transform: translateX(-50%);
  }

  /* Hide line on last card */
  .about-narrative__card:last-child::before {
    display: none;
  }

  .about-narrative__card-icon-wrapper {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 3rem;
    height: 3rem;
    background-color: var(--color-background, #ffffff);
    border: 2px solid var(--card-icon-color, var(--color-accent));
    border-radius: 50%;
    flex-shrink: 0;
    position: relative;
    z-index: 1;
  }

  .about-narrative__card-icon {
    width: 1.5rem;
    height: 1.5rem;
    color: var(--card-icon-color, var(--color-accent));
  }

  .about-narrative__card-body {
    flex: 1;
    min-width: 0;
  }

  .about-narrative__card-title {
    font-family: var(--font-heading);
    font-size: 1.375rem;
    font-weight: 600;
    color: var(--card-title-color, var(--color-text));
    margin: 0 0 0.75rem;
    padding-top: 0.6rem;
    line-height: 1.2;
  }

  .about-narrative__card-content {
    color: var(--color-text-muted);
    line-height: 1.7;
  }

  .about-narrative__card-content :global(p) {
    margin: 0 0 1.5rem;
  }

  .about-narrative__card-content :global(p:last-child) {
    margin-bottom: 0;
  }

  .about-narrative__card-content :global(strong) {
    font-weight: 600;
    color: var(--color-text);
  }

  .about-narrative__card-content :global(em) {
    font-style: italic;
  }

  .about-narrative__card-content :global(a) {
    color: var(--card-title-color, var(--color-accent));
    text-decoration: underline;
    text-underline-offset: 2px;
    transition: opacity 0.2s ease;
  }

  .about-narrative__card-content :global(a:hover) {
    opacity: 0.8;
  }

  /* Reduced motion support */
  @media (prefers-reduced-motion: reduce) {
    .about-narrative__card {
      opacity: 1 !important;
      transform: none !important;
    }
  }
</style>

<script>
  import { setupAnimationLifecycle, gsap } from '@lib/animation/utils';
  import { ANIMATION_CONFIG } from '@lib/animation/config';

  setupAnimationLifecycle(() => {
    const section = document.querySelector('.about-narrative');
    if (!section) return;

    // Check for reduced motion preference
    const prefersReducedMotion = window.matchMedia(
      '(prefers-reduced-motion: reduce)'
    ).matches;

    if (prefersReducedMotion) {
      gsap.set(section.querySelectorAll('.about-narrative__card'), {
        opacity: 1,
        transform: 'none',
      });
      return;
    }

    const cards = section.querySelectorAll('.about-narrative__card');
    const icons = section.querySelectorAll(
      '.about-narrative__card-icon-wrapper'
    );

    // Initial states for cards
    gsap.set(cards, { opacity: 0, y: 40 });
    gsap.set(icons, { scale: 0.8, rotation: -10 });

    // Staggered card entrance - each card triggers independently
    cards.forEach((card) => {
      const icon = card.querySelector('.about-narrative__card-icon-wrapper');

      gsap.to(card, {
        opacity: 1,
        y: 0,
        duration: 0.6,
        ease: 'power3.out',
        scrollTrigger: {
          trigger: card,
          start: 'top 85%',
          once: true,
          markers: ANIMATION_CONFIG.scrollTrigger.markers,
        },
      });

      // Icon pops in slightly after card
      if (icon) {
        gsap.to(icon, {
          scale: 1,
          rotation: 0,
          duration: 0.5,
          ease: 'back.out(1.7)',
          scrollTrigger: {
            trigger: card,
            start: 'top 85%',
            once: true,
            markers: ANIMATION_CONFIG.scrollTrigger.markers,
          },
          delay: 0.2,
        });
      }
    });

    // GSAP ScrollTrigger PIN for sticky image (CSS sticky breaks with Lenis)
    const imageColumn = section.querySelector('.about-narrative__image-column');
    const cardsColumn = section.querySelector('.about-narrative__cards-column');

    if (imageColumn && cardsColumn) {
      const mm = gsap.matchMedia();

      mm.add('(min-width: 768px)', () => {
        const imageHeight = imageColumn.getBoundingClientRect().height;

        gsap.to(imageColumn, {
          scrollTrigger: {
            trigger: imageColumn,
            start: 'top 128px',
            endTrigger: cardsColumn,
            end: `bottom ${128 + imageHeight}px`,
            pin: true,
            pinSpacing: false,
            markers: ANIMATION_CONFIG.scrollTrigger.markers,
          },
        });
      });
    }
  });
</script>
