---
import { resolveColorSelection } from '@lib/sanity/colorResolver';
import { sanityClient as client } from 'sanity:client';
import { siteSettingsQuery } from '@lib/sanity/queries';
import CoreValueCard from '@components/cards/CoreValueCard.astro';

interface ColorData {
  label?: string;
  value: string;
}

interface ValueCard {
  _key: string;
  icon?: { name: string };
  iconColorType?: 'primary' | 'secondary' | 'accent' | 'custom';
  iconColorShade?: number;
  iconCustomColor?: ColorData;
  title: string;
  titleColorType?: 'primary' | 'secondary' | 'accent' | 'custom';
  titleColorShade?: number;
  titleCustomColor?: ColorData;
  description: string;
}

interface Props {
  title?: string;
  showTitle?: boolean;
  titleColorType?: 'primary' | 'secondary' | 'accent' | 'custom';
  titleColorShade?: number;
  titleCustomColor?: ColorData;
  cards: ValueCard[];
  backgroundColorType?:
    | 'default'
    | 'primary'
    | 'secondary'
    | 'accent'
    | 'custom';
  backgroundColorShade?: number;
  backgroundCustomColor?: ColorData;
  cardBackgroundColorType?:
    | 'default'
    | 'primary'
    | 'secondary'
    | 'accent'
    | 'custom';
  cardBackgroundColorShade?: number;
  cardBackgroundCustomColor?: ColorData;
  cardTitleColorType?: 'primary' | 'secondary' | 'accent' | 'custom';
  cardTitleColorShade?: number;
  cardTitleCustomColor?: ColorData;
}

const {
  title,
  showTitle = true,
  titleColorType = 'primary',
  titleColorShade = 0,
  titleCustomColor,
  cards,
  backgroundColorType = 'default',
  backgroundColorShade = 90,
  backgroundCustomColor,
  cardBackgroundColorType = 'default',
  cardBackgroundColorShade = 95,
  cardBackgroundCustomColor,
  cardTitleColorType = 'accent',
  cardTitleColorShade = 0,
  cardTitleCustomColor,
} = Astro.props;

// Fetch site settings for colors
const settings = await client.fetch(siteSettingsQuery);
const siteColors = settings?.colors;

// Lighten a hex color by mixing with white
function lightenColor(hex: string, amount: number): string {
  const cleanHex = hex.replace('#', '');
  const r = parseInt(cleanHex.substring(0, 2), 16);
  const g = parseInt(cleanHex.substring(2, 4), 16);
  const b = parseInt(cleanHex.substring(4, 6), 16);

  const newR = Math.round(r + (255 - r) * amount);
  const newG = Math.round(g + (255 - g) * amount);
  const newB = Math.round(b + (255 - b) * amount);

  const toHex = (n: number) =>
    Math.max(0, Math.min(255, n)).toString(16).padStart(2, '0');
  return `#${toHex(newR)}${toHex(newG)}${toHex(newB)}`;
}

// Helper to resolve icon colors for each card
function getCardIconColors(card: ValueCard) {
  const iconColor =
    card.iconColorType === 'custom' && card.iconCustomColor?.value
      ? card.iconCustomColor.value
      : resolveColorSelection(
          {
            colorType: card.iconColorType || 'accent',
            shade: card.iconColorShade || 0,
            customColor: card.iconCustomColor,
          },
          siteColors
        );

  // Create a light background version of the icon color
  // For custom colors, lighten by 85% to create a subtle background
  // For theme colors, use shade 90
  let iconBgColor: string;
  if (card.iconColorType === 'custom' && card.iconCustomColor?.value) {
    iconBgColor = lightenColor(card.iconCustomColor.value, 0.85);
  } else {
    iconBgColor = resolveColorSelection(
      {
        colorType: card.iconColorType || 'accent',
        shade: 90,
        customColor: card.iconCustomColor,
      },
      siteColors
    );
  }

  return { iconColor, iconBgColor };
}

// Resolve section background color
const sectionBackgroundColor =
  backgroundColorType === 'default'
    ? null
    : resolveColorSelection(
        {
          colorType: backgroundColorType,
          shade: backgroundColorShade,
          customColor: backgroundCustomColor,
        },
        siteColors
      );

// Resolve card background color
const cardBackgroundColor =
  cardBackgroundColorType === 'default'
    ? null
    : resolveColorSelection(
        {
          colorType: cardBackgroundColorType,
          shade: cardBackgroundColorShade,
          customColor: cardBackgroundCustomColor,
        },
        siteColors
      );

// Resolve section-level card title color
const cardTitleColor = resolveColorSelection(
  {
    colorType: cardTitleColorType,
    shade: cardTitleColorShade,
    customColor: cardTitleCustomColor,
  },
  siteColors
);

// Resolve section title color
const sectionTitleColor = resolveColorSelection(
  {
    colorType: titleColorType,
    shade: titleColorShade,
    customColor: titleCustomColor,
  },
  siteColors
);

const sectionCssVars = [
  sectionBackgroundColor ? `--section-bg: ${sectionBackgroundColor}` : null,
  cardBackgroundColor ? `--card-bg: ${cardBackgroundColor}` : null,
  `--card-title-color: ${cardTitleColor}`,
  `--section-title-color: ${sectionTitleColor}`,
]
  .filter(Boolean)
  .join('; ');
---

<section class="core-values" style={sectionCssVars}>
  <div class="container">
    {
      title && (
        <h2
          class:list={['core-values__title', { 'visually-hidden': !showTitle }]}
        >
          {title}
        </h2>
      )
    }
    <div class="core-values__grid">
      {
        cards.map((card) => {
          const colors = getCardIconColors(card);
          return (
            <CoreValueCard
              iconName={card.icon?.name}
              iconColor={colors.iconColor}
              iconBgColor={colors.iconBgColor}
              title={card.title}
              titleColor={cardTitleColor}
              description={card.description}
              cardBgColor={cardBackgroundColor || undefined}
            />
          );
        })
      }
    </div>
  </div>
</section>

<style>
  .core-values {
    padding: var(--space-2xl) 0;
    background-color: var(--section-bg, transparent);
  }

  .core-values__title {
    font-family: var(--font-heading);
    font-size: clamp(1.75rem, 4vw, 2.5rem);
    font-weight: 500;
    line-height: 1.2;
    color: var(--section-title-color);
    margin: 0 0 var(--space-lg);
    text-align: center;
  }

  .core-values__grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: var(--space-xl);
  }

  .visually-hidden {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }
</style>

<script>
  import { setupAnimationLifecycle, gsap } from '@lib/animation/utils';
  import { ANIMATION_CONFIG } from '@lib/animation/config';

  setupAnimationLifecycle(() => {
    const cards = document.querySelectorAll('.core-values__card');
    const icons = document.querySelectorAll('.core-values__icon-wrapper');

    if (cards.length === 0) return;

    // Initial states
    gsap.set(cards, { opacity: 0, y: 50 });
    gsap.set(icons, { scale: 0.8, rotation: -10 });

    // Staggered card entrance
    cards.forEach((card, index) => {
      const icon = card.querySelector('.core-values__icon-wrapper');

      gsap.to(card, {
        opacity: 1,
        y: 0,
        duration: 0.6,
        ease: 'power3.out',
        scrollTrigger: {
          trigger: card,
          start: 'top 85%',
          once: true,
          markers: ANIMATION_CONFIG.scrollTrigger.markers,
        },
        delay: index * 0.1,
      });

      // Icon pops in slightly after card
      if (icon) {
        gsap.to(icon, {
          scale: 1,
          rotation: 0,
          duration: 0.5,
          ease: 'back.out(1.7)',
          scrollTrigger: {
            trigger: card,
            start: 'top 85%',
            once: true,
            markers: ANIMATION_CONFIG.scrollTrigger.markers,
          },
          delay: index * 0.1 + 0.2,
        });
      }
    });
  });
</script>
